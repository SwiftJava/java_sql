
import java_swift
import java_util

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.sql.PreparedStatement ///

public protocol PreparedStatement: Statement {

    /// public abstract boolean java.sql.PreparedStatement.execute() throws java.sql.SQLException

    func execute() throws /* java.sql.SQLException */ -> Bool

    /// public abstract void java.sql.PreparedStatement.setBoolean(int,boolean) throws java.sql.SQLException

    func setBoolean( parameterIndex: Int, x: Bool ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setByte(int,byte) throws java.sql.SQLException

    func setByte( parameterIndex: Int, x: Int8 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setShort(int,short) throws java.sql.SQLException

    func setShort( parameterIndex: Int, x: Int16 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setInt(int,int) throws java.sql.SQLException

    func setInt( parameterIndex: Int, x: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setLong(int,long) throws java.sql.SQLException

    func setLong( parameterIndex: Int, x: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setFloat(int,float) throws java.sql.SQLException

    func setFloat( parameterIndex: Int, x: Float ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setDouble(int,double) throws java.sql.SQLException

    func setDouble( parameterIndex: Int, x: Double ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setTimestamp(int,java.sql.Timestamp,java.util.Calendar) throws java.sql.SQLException

    func setTimestamp( parameterIndex: Int, x: Timestamp?, cal: java_util.Calendar? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setTimestamp(int,java.sql.Timestamp) throws java.sql.SQLException

    func setTimestamp( parameterIndex: Int, x: Timestamp? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setObject(int,java.lang.Object,int) throws java.sql.SQLException

    func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: Int ) throws /* java.sql.SQLException */

    /// public default void java.sql.PreparedStatement.setObject(int,java.lang.Object,java.sql.SQLType) throws java.sql.SQLException

    func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: SQLType? ) throws /* java.sql.SQLException */

    /// public default void java.sql.PreparedStatement.setObject(int,java.lang.Object,java.sql.SQLType,int) throws java.sql.SQLException

    func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: SQLType?, scaleOrLength: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setObject(int,java.lang.Object,int,int) throws java.sql.SQLException

    func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: Int, scaleOrLength: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setObject(int,java.lang.Object) throws java.sql.SQLException

    func setObject( parameterIndex: Int, x: java_swift.JavaObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBytes(int,byte[]) throws java.sql.SQLException

    func setBytes( parameterIndex: Int, x: [Int8]? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBinaryStream(int,java.io.InputStream,long) throws java.sql.SQLException

    func setBinaryStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBinaryStream(int,java.io.InputStream) throws java.sql.SQLException

    func setBinaryStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBinaryStream(int,java.io.InputStream,int) throws java.sql.SQLException

    func setBinaryStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNull(int,int) throws java.sql.SQLException

    func setNull( parameterIndex: Int, sqlType: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNull(int,int,java.lang.String) throws java.sql.SQLException

    func setNull( parameterIndex: Int, sqlType: Int, typeName: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBigDecimal(int,java.math.BigDecimal) throws java.sql.SQLException

    func setBigDecimal( parameterIndex: Int, x: /* java.math.BigDecimal */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setString(int,java.lang.String) throws java.sql.SQLException

    func setString( parameterIndex: Int, x: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setDate(int,java.sql.Date,java.util.Calendar) throws java.sql.SQLException

    func setDate( parameterIndex: Int, x: Date?, cal: java_util.Calendar? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setDate(int,java.sql.Date) throws java.sql.SQLException

    func setDate( parameterIndex: Int, x: Date? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setAsciiStream(int,java.io.InputStream,long) throws java.sql.SQLException

    func setAsciiStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setAsciiStream(int,java.io.InputStream,int) throws java.sql.SQLException

    func setAsciiStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setAsciiStream(int,java.io.InputStream) throws java.sql.SQLException

    func setAsciiStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setCharacterStream(int,java.io.Reader) throws java.sql.SQLException

    func setCharacterStream( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setCharacterStream(int,java.io.Reader,long) throws java.sql.SQLException

    func setCharacterStream( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setCharacterStream(int,java.io.Reader,int) throws java.sql.SQLException

    func setCharacterStream( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setRowId(int,java.sql.RowId) throws java.sql.SQLException

    func setRowId( parameterIndex: Int, x: RowId? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNString(int,java.lang.String) throws java.sql.SQLException

    func setNString( parameterIndex: Int, value: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNCharacterStream(int,java.io.Reader,long) throws java.sql.SQLException

    func setNCharacterStream( parameterIndex: Int, value: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNCharacterStream(int,java.io.Reader) throws java.sql.SQLException

    func setNCharacterStream( parameterIndex: Int, value: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNClob(int,java.sql.NClob) throws java.sql.SQLException

    func setNClob( parameterIndex: Int, value: NClob? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNClob(int,java.io.Reader,long) throws java.sql.SQLException

    func setNClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setNClob(int,java.io.Reader) throws java.sql.SQLException

    func setNClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setClob(int,java.io.Reader,long) throws java.sql.SQLException

    func setClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setClob(int,java.sql.Clob) throws java.sql.SQLException

    func setClob( parameterIndex: Int, x: Clob? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setClob(int,java.io.Reader) throws java.sql.SQLException

    func setClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBlob(int,java.io.InputStream,long) throws java.sql.SQLException

    func setBlob( parameterIndex: Int, inputStream: /* java.io.InputStream */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBlob(int,java.io.InputStream) throws java.sql.SQLException

    func setBlob( parameterIndex: Int, inputStream: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setBlob(int,java.sql.Blob) throws java.sql.SQLException

    func setBlob( parameterIndex: Int, x: Blob? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setSQLXML(int,java.sql.SQLXML) throws java.sql.SQLException

    func setSQLXML( parameterIndex: Int, xmlObject: SQLXML? ) throws /* java.sql.SQLException */

    /// public abstract java.sql.ResultSet java.sql.PreparedStatement.executeQuery() throws java.sql.SQLException

    func executeQuery() throws /* java.sql.SQLException */ -> ResultSet!

    /// public abstract int java.sql.PreparedStatement.executeUpdate() throws java.sql.SQLException

    func executeUpdate() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.PreparedStatement.setUnicodeStream(int,java.io.InputStream,int) throws java.sql.SQLException

    func setUnicodeStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.clearParameters() throws java.sql.SQLException

    func clearParameters() throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.addBatch() throws java.sql.SQLException

    func addBatch() throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setRef(int,java.sql.Ref) throws java.sql.SQLException

    func setRef( parameterIndex: Int, x: Ref? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setArray(int,java.sql.Array) throws java.sql.SQLException

    func setArray( parameterIndex: Int, x: Array? ) throws /* java.sql.SQLException */

    /// public abstract java.sql.ParameterMetaData java.sql.PreparedStatement.getParameterMetaData() throws java.sql.SQLException

    func getParameterMetaData() throws /* java.sql.SQLException */ -> ParameterMetaData!

    /// public default long java.sql.PreparedStatement.executeLargeUpdate() throws java.sql.SQLException

    func executeLargeUpdate() throws /* java.sql.SQLException */ -> Int64

    /// public abstract java.sql.ResultSetMetaData java.sql.PreparedStatement.getMetaData() throws java.sql.SQLException

    func getMetaData() throws /* java.sql.SQLException */ -> ResultSetMetaData!

    /// public abstract void java.sql.PreparedStatement.setURL(int,java.net.URL) throws java.sql.SQLException

    func setURL( parameterIndex: Int, x: /* java.net.URL */ UnclassedObject? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setTime(int,java.sql.Time) throws java.sql.SQLException

    func setTime( parameterIndex: Int, x: Time? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.PreparedStatement.setTime(int,java.sql.Time,java.util.Calendar) throws java.sql.SQLException

    func setTime( parameterIndex: Int, x: Time?, cal: java_util.Calendar? ) throws /* java.sql.SQLException */

}


open class PreparedStatementForward: StatementForward, PreparedStatement {

    private static var PreparedStatementJNIClass: jclass?

    /// public abstract boolean java.sql.PreparedStatement.execute() throws java.sql.SQLException

    private static var execute_MethodID_59: jmethodID?

    open func execute() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "()Z", methodCache: &PreparedStatementForward.execute_MethodID_59, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public abstract void java.sql.PreparedStatement.setBoolean(int,boolean) throws java.sql.SQLException

    private static var setBoolean_MethodID_60: jmethodID?

    open func setBoolean( parameterIndex: Int, x: Bool ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBoolean", methodSig: "(IZ)V", methodCache: &PreparedStatementForward.setBoolean_MethodID_60, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBoolean( _ _parameterIndex: Int, _ _x: Bool ) throws /* java.sql.SQLException */ {
        try setBoolean( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setByte(int,byte) throws java.sql.SQLException

    private static var setByte_MethodID_61: jmethodID?

    open func setByte( parameterIndex: Int, x: Int8 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setByte", methodSig: "(IB)V", methodCache: &PreparedStatementForward.setByte_MethodID_61, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setByte( _ _parameterIndex: Int, _ _x: Int8 ) throws /* java.sql.SQLException */ {
        try setByte( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setShort(int,short) throws java.sql.SQLException

    private static var setShort_MethodID_62: jmethodID?

    open func setShort( parameterIndex: Int, x: Int16 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setShort", methodSig: "(IS)V", methodCache: &PreparedStatementForward.setShort_MethodID_62, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setShort( _ _parameterIndex: Int, _ _x: Int16 ) throws /* java.sql.SQLException */ {
        try setShort( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setInt(int,int) throws java.sql.SQLException

    private static var setInt_MethodID_63: jmethodID?

    open func setInt( parameterIndex: Int, x: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setInt", methodSig: "(II)V", methodCache: &PreparedStatementForward.setInt_MethodID_63, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setInt( _ _parameterIndex: Int, _ _x: Int ) throws /* java.sql.SQLException */ {
        try setInt( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setLong(int,long) throws java.sql.SQLException

    private static var setLong_MethodID_64: jmethodID?

    open func setLong( parameterIndex: Int, x: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLong", methodSig: "(IJ)V", methodCache: &PreparedStatementForward.setLong_MethodID_64, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setLong( _ _parameterIndex: Int, _ _x: Int64 ) throws /* java.sql.SQLException */ {
        try setLong( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setFloat(int,float) throws java.sql.SQLException

    private static var setFloat_MethodID_65: jmethodID?

    open func setFloat( parameterIndex: Int, x: Float ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFloat", methodSig: "(IF)V", methodCache: &PreparedStatementForward.setFloat_MethodID_65, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setFloat( _ _parameterIndex: Int, _ _x: Float ) throws /* java.sql.SQLException */ {
        try setFloat( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setDouble(int,double) throws java.sql.SQLException

    private static var setDouble_MethodID_66: jmethodID?

    open func setDouble( parameterIndex: Int, x: Double ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setDouble", methodSig: "(ID)V", methodCache: &PreparedStatementForward.setDouble_MethodID_66, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setDouble( _ _parameterIndex: Int, _ _x: Double ) throws /* java.sql.SQLException */ {
        try setDouble( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setTimestamp(int,java.sql.Timestamp,java.util.Calendar) throws java.sql.SQLException

    private static var setTimestamp_MethodID_67: jmethodID?

    open func setTimestamp( parameterIndex: Int, x: Timestamp?, cal: java_util.Calendar? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: cal != nil ? cal! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTimestamp", methodSig: "(ILjava/sql/Timestamp;Ljava/util/Calendar;)V", methodCache: &PreparedStatementForward.setTimestamp_MethodID_67, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setTimestamp( _ _parameterIndex: Int, _ _x: Timestamp?, _ _cal: java_util.Calendar? ) throws /* java.sql.SQLException */ {
        try setTimestamp( parameterIndex: _parameterIndex, x: _x, cal: _cal )
    }

    /// public abstract void java.sql.PreparedStatement.setTimestamp(int,java.sql.Timestamp) throws java.sql.SQLException

    private static var setTimestamp_MethodID_68: jmethodID?

    open func setTimestamp( parameterIndex: Int, x: Timestamp? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTimestamp", methodSig: "(ILjava/sql/Timestamp;)V", methodCache: &PreparedStatementForward.setTimestamp_MethodID_68, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setTimestamp( _ _parameterIndex: Int, _ _x: Timestamp? ) throws /* java.sql.SQLException */ {
        try setTimestamp( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setObject(int,java.lang.Object,int) throws java.sql.SQLException

    private static var setObject_MethodID_69: jmethodID?

    open func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: targetSqlType, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setObject", methodSig: "(ILjava/lang/Object;I)V", methodCache: &PreparedStatementForward.setObject_MethodID_69, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setObject( _ _parameterIndex: Int, _ _x: java_swift.JavaObject?, _ _targetSqlType: Int ) throws /* java.sql.SQLException */ {
        try setObject( parameterIndex: _parameterIndex, x: _x, targetSqlType: _targetSqlType )
    }

    /// public default void java.sql.PreparedStatement.setObject(int,java.lang.Object,java.sql.SQLType) throws java.sql.SQLException

    private static var setObject_MethodID_70: jmethodID?

    open func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: SQLType? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: targetSqlType, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setObject", methodSig: "(ILjava/lang/Object;Ljava/sql/SQLType;)V", methodCache: &PreparedStatementForward.setObject_MethodID_70, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setObject( _ _parameterIndex: Int, _ _x: java_swift.JavaObject?, _ _targetSqlType: SQLType? ) throws /* java.sql.SQLException */ {
        try setObject( parameterIndex: _parameterIndex, x: _x, targetSqlType: _targetSqlType )
    }

    /// public default void java.sql.PreparedStatement.setObject(int,java.lang.Object,java.sql.SQLType,int) throws java.sql.SQLException

    private static var setObject_MethodID_71: jmethodID?

    open func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: SQLType?, scaleOrLength: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: targetSqlType, locals: &__locals )
        __args[3] = JNIType.toJava( value: scaleOrLength, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setObject", methodSig: "(ILjava/lang/Object;Ljava/sql/SQLType;I)V", methodCache: &PreparedStatementForward.setObject_MethodID_71, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setObject( _ _parameterIndex: Int, _ _x: java_swift.JavaObject?, _ _targetSqlType: SQLType?, _ _scaleOrLength: Int ) throws /* java.sql.SQLException */ {
        try setObject( parameterIndex: _parameterIndex, x: _x, targetSqlType: _targetSqlType, scaleOrLength: _scaleOrLength )
    }

    /// public abstract void java.sql.PreparedStatement.setObject(int,java.lang.Object,int,int) throws java.sql.SQLException

    private static var setObject_MethodID_72: jmethodID?

    open func setObject( parameterIndex: Int, x: java_swift.JavaObject?, targetSqlType: Int, scaleOrLength: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: targetSqlType, locals: &__locals )
        __args[3] = JNIType.toJava( value: scaleOrLength, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setObject", methodSig: "(ILjava/lang/Object;II)V", methodCache: &PreparedStatementForward.setObject_MethodID_72, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setObject( _ _parameterIndex: Int, _ _x: java_swift.JavaObject?, _ _targetSqlType: Int, _ _scaleOrLength: Int ) throws /* java.sql.SQLException */ {
        try setObject( parameterIndex: _parameterIndex, x: _x, targetSqlType: _targetSqlType, scaleOrLength: _scaleOrLength )
    }

    /// public abstract void java.sql.PreparedStatement.setObject(int,java.lang.Object) throws java.sql.SQLException

    private static var setObject_MethodID_73: jmethodID?

    open func setObject( parameterIndex: Int, x: java_swift.JavaObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setObject", methodSig: "(ILjava/lang/Object;)V", methodCache: &PreparedStatementForward.setObject_MethodID_73, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setObject( _ _parameterIndex: Int, _ _x: java_swift.JavaObject? ) throws /* java.sql.SQLException */ {
        try setObject( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setBytes(int,byte[]) throws java.sql.SQLException

    private static var setBytes_MethodID_74: jmethodID?

    open func setBytes( parameterIndex: Int, x: [Int8]? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBytes", methodSig: "(I[B)V", methodCache: &PreparedStatementForward.setBytes_MethodID_74, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBytes( _ _parameterIndex: Int, _ _x: [Int8]? ) throws /* java.sql.SQLException */ {
        try setBytes( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setBinaryStream(int,java.io.InputStream,long) throws java.sql.SQLException

    private static var setBinaryStream_MethodID_75: jmethodID?

    open func setBinaryStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBinaryStream", methodSig: "(ILjava/io/InputStream;J)V", methodCache: &PreparedStatementForward.setBinaryStream_MethodID_75, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBinaryStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setBinaryStream( parameterIndex: _parameterIndex, x: _x, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setBinaryStream(int,java.io.InputStream) throws java.sql.SQLException

    private static var setBinaryStream_MethodID_76: jmethodID?

    open func setBinaryStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBinaryStream", methodSig: "(ILjava/io/InputStream;)V", methodCache: &PreparedStatementForward.setBinaryStream_MethodID_76, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBinaryStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setBinaryStream( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setBinaryStream(int,java.io.InputStream,int) throws java.sql.SQLException

    private static var setBinaryStream_MethodID_77: jmethodID?

    open func setBinaryStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBinaryStream", methodSig: "(ILjava/io/InputStream;I)V", methodCache: &PreparedStatementForward.setBinaryStream_MethodID_77, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBinaryStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject?, _ _length: Int ) throws /* java.sql.SQLException */ {
        try setBinaryStream( parameterIndex: _parameterIndex, x: _x, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setNull(int,int) throws java.sql.SQLException

    private static var setNull_MethodID_78: jmethodID?

    open func setNull( parameterIndex: Int, sqlType: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: sqlType, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNull", methodSig: "(II)V", methodCache: &PreparedStatementForward.setNull_MethodID_78, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNull( _ _parameterIndex: Int, _ _sqlType: Int ) throws /* java.sql.SQLException */ {
        try setNull( parameterIndex: _parameterIndex, sqlType: _sqlType )
    }

    /// public abstract void java.sql.PreparedStatement.setNull(int,int,java.lang.String) throws java.sql.SQLException

    private static var setNull_MethodID_79: jmethodID?

    open func setNull( parameterIndex: Int, sqlType: Int, typeName: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: sqlType, locals: &__locals )
        __args[2] = JNIType.toJava( value: typeName, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNull", methodSig: "(IILjava/lang/String;)V", methodCache: &PreparedStatementForward.setNull_MethodID_79, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNull( _ _parameterIndex: Int, _ _sqlType: Int, _ _typeName: String? ) throws /* java.sql.SQLException */ {
        try setNull( parameterIndex: _parameterIndex, sqlType: _sqlType, typeName: _typeName )
    }

    /// public abstract void java.sql.PreparedStatement.setBigDecimal(int,java.math.BigDecimal) throws java.sql.SQLException

    private static var setBigDecimal_MethodID_80: jmethodID?

    open func setBigDecimal( parameterIndex: Int, x: /* java.math.BigDecimal */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBigDecimal", methodSig: "(ILjava/math/BigDecimal;)V", methodCache: &PreparedStatementForward.setBigDecimal_MethodID_80, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBigDecimal( _ _parameterIndex: Int, _ _x: /* java.math.BigDecimal */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setBigDecimal( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setString(int,java.lang.String) throws java.sql.SQLException

    private static var setString_MethodID_81: jmethodID?

    open func setString( parameterIndex: Int, x: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setString", methodSig: "(ILjava/lang/String;)V", methodCache: &PreparedStatementForward.setString_MethodID_81, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setString( _ _parameterIndex: Int, _ _x: String? ) throws /* java.sql.SQLException */ {
        try setString( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setDate(int,java.sql.Date,java.util.Calendar) throws java.sql.SQLException

    private static var setDate_MethodID_82: jmethodID?

    open func setDate( parameterIndex: Int, x: Date?, cal: java_util.Calendar? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: cal != nil ? cal! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setDate", methodSig: "(ILjava/sql/Date;Ljava/util/Calendar;)V", methodCache: &PreparedStatementForward.setDate_MethodID_82, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setDate( _ _parameterIndex: Int, _ _x: Date?, _ _cal: java_util.Calendar? ) throws /* java.sql.SQLException */ {
        try setDate( parameterIndex: _parameterIndex, x: _x, cal: _cal )
    }

    /// public abstract void java.sql.PreparedStatement.setDate(int,java.sql.Date) throws java.sql.SQLException

    private static var setDate_MethodID_83: jmethodID?

    open func setDate( parameterIndex: Int, x: Date? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setDate", methodSig: "(ILjava/sql/Date;)V", methodCache: &PreparedStatementForward.setDate_MethodID_83, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setDate( _ _parameterIndex: Int, _ _x: Date? ) throws /* java.sql.SQLException */ {
        try setDate( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setAsciiStream(int,java.io.InputStream,long) throws java.sql.SQLException

    private static var setAsciiStream_MethodID_84: jmethodID?

    open func setAsciiStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setAsciiStream", methodSig: "(ILjava/io/InputStream;J)V", methodCache: &PreparedStatementForward.setAsciiStream_MethodID_84, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setAsciiStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setAsciiStream( parameterIndex: _parameterIndex, x: _x, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setAsciiStream(int,java.io.InputStream,int) throws java.sql.SQLException

    private static var setAsciiStream_MethodID_85: jmethodID?

    open func setAsciiStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setAsciiStream", methodSig: "(ILjava/io/InputStream;I)V", methodCache: &PreparedStatementForward.setAsciiStream_MethodID_85, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setAsciiStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject?, _ _length: Int ) throws /* java.sql.SQLException */ {
        try setAsciiStream( parameterIndex: _parameterIndex, x: _x, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setAsciiStream(int,java.io.InputStream) throws java.sql.SQLException

    private static var setAsciiStream_MethodID_86: jmethodID?

    open func setAsciiStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setAsciiStream", methodSig: "(ILjava/io/InputStream;)V", methodCache: &PreparedStatementForward.setAsciiStream_MethodID_86, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setAsciiStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setAsciiStream( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setCharacterStream(int,java.io.Reader) throws java.sql.SQLException

    private static var setCharacterStream_MethodID_87: jmethodID?

    open func setCharacterStream( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCharacterStream", methodSig: "(ILjava/io/Reader;)V", methodCache: &PreparedStatementForward.setCharacterStream_MethodID_87, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setCharacterStream( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setCharacterStream( parameterIndex: _parameterIndex, reader: _reader )
    }

    /// public abstract void java.sql.PreparedStatement.setCharacterStream(int,java.io.Reader,long) throws java.sql.SQLException

    private static var setCharacterStream_MethodID_88: jmethodID?

    open func setCharacterStream( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCharacterStream", methodSig: "(ILjava/io/Reader;J)V", methodCache: &PreparedStatementForward.setCharacterStream_MethodID_88, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setCharacterStream( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setCharacterStream( parameterIndex: _parameterIndex, reader: _reader, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setCharacterStream(int,java.io.Reader,int) throws java.sql.SQLException

    private static var setCharacterStream_MethodID_89: jmethodID?

    open func setCharacterStream( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCharacterStream", methodSig: "(ILjava/io/Reader;I)V", methodCache: &PreparedStatementForward.setCharacterStream_MethodID_89, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setCharacterStream( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject?, _ _length: Int ) throws /* java.sql.SQLException */ {
        try setCharacterStream( parameterIndex: _parameterIndex, reader: _reader, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setRowId(int,java.sql.RowId) throws java.sql.SQLException

    private static var setRowId_MethodID_90: jmethodID?

    open func setRowId( parameterIndex: Int, x: RowId? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setRowId", methodSig: "(ILjava/sql/RowId;)V", methodCache: &PreparedStatementForward.setRowId_MethodID_90, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setRowId( _ _parameterIndex: Int, _ _x: RowId? ) throws /* java.sql.SQLException */ {
        try setRowId( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setNString(int,java.lang.String) throws java.sql.SQLException

    private static var setNString_MethodID_91: jmethodID?

    open func setNString( parameterIndex: Int, value: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: value, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNString", methodSig: "(ILjava/lang/String;)V", methodCache: &PreparedStatementForward.setNString_MethodID_91, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNString( _ _parameterIndex: Int, _ _value: String? ) throws /* java.sql.SQLException */ {
        try setNString( parameterIndex: _parameterIndex, value: _value )
    }

    /// public abstract void java.sql.PreparedStatement.setNCharacterStream(int,java.io.Reader,long) throws java.sql.SQLException

    private static var setNCharacterStream_MethodID_92: jmethodID?

    open func setNCharacterStream( parameterIndex: Int, value: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: value != nil ? value! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNCharacterStream", methodSig: "(ILjava/io/Reader;J)V", methodCache: &PreparedStatementForward.setNCharacterStream_MethodID_92, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNCharacterStream( _ _parameterIndex: Int, _ _value: /* java.io.Reader */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setNCharacterStream( parameterIndex: _parameterIndex, value: _value, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setNCharacterStream(int,java.io.Reader) throws java.sql.SQLException

    private static var setNCharacterStream_MethodID_93: jmethodID?

    open func setNCharacterStream( parameterIndex: Int, value: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: value != nil ? value! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNCharacterStream", methodSig: "(ILjava/io/Reader;)V", methodCache: &PreparedStatementForward.setNCharacterStream_MethodID_93, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNCharacterStream( _ _parameterIndex: Int, _ _value: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setNCharacterStream( parameterIndex: _parameterIndex, value: _value )
    }

    /// public abstract void java.sql.PreparedStatement.setNClob(int,java.sql.NClob) throws java.sql.SQLException

    private static var setNClob_MethodID_94: jmethodID?

    open func setNClob( parameterIndex: Int, value: NClob? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: value, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNClob", methodSig: "(ILjava/sql/NClob;)V", methodCache: &PreparedStatementForward.setNClob_MethodID_94, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNClob( _ _parameterIndex: Int, _ _value: NClob? ) throws /* java.sql.SQLException */ {
        try setNClob( parameterIndex: _parameterIndex, value: _value )
    }

    /// public abstract void java.sql.PreparedStatement.setNClob(int,java.io.Reader,long) throws java.sql.SQLException

    private static var setNClob_MethodID_95: jmethodID?

    open func setNClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNClob", methodSig: "(ILjava/io/Reader;J)V", methodCache: &PreparedStatementForward.setNClob_MethodID_95, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNClob( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setNClob( parameterIndex: _parameterIndex, reader: _reader, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setNClob(int,java.io.Reader) throws java.sql.SQLException

    private static var setNClob_MethodID_96: jmethodID?

    open func setNClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNClob", methodSig: "(ILjava/io/Reader;)V", methodCache: &PreparedStatementForward.setNClob_MethodID_96, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNClob( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setNClob( parameterIndex: _parameterIndex, reader: _reader )
    }

    /// public abstract void java.sql.PreparedStatement.setClob(int,java.io.Reader,long) throws java.sql.SQLException

    private static var setClob_MethodID_97: jmethodID?

    open func setClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setClob", methodSig: "(ILjava/io/Reader;J)V", methodCache: &PreparedStatementForward.setClob_MethodID_97, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setClob( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setClob( parameterIndex: _parameterIndex, reader: _reader, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setClob(int,java.sql.Clob) throws java.sql.SQLException

    private static var setClob_MethodID_98: jmethodID?

    open func setClob( parameterIndex: Int, x: Clob? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setClob", methodSig: "(ILjava/sql/Clob;)V", methodCache: &PreparedStatementForward.setClob_MethodID_98, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setClob( _ _parameterIndex: Int, _ _x: Clob? ) throws /* java.sql.SQLException */ {
        try setClob( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setClob(int,java.io.Reader) throws java.sql.SQLException

    private static var setClob_MethodID_99: jmethodID?

    open func setClob( parameterIndex: Int, reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: reader != nil ? reader! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setClob", methodSig: "(ILjava/io/Reader;)V", methodCache: &PreparedStatementForward.setClob_MethodID_99, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setClob( _ _parameterIndex: Int, _ _reader: /* java.io.Reader */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setClob( parameterIndex: _parameterIndex, reader: _reader )
    }

    /// public abstract void java.sql.PreparedStatement.setBlob(int,java.io.InputStream,long) throws java.sql.SQLException

    private static var setBlob_MethodID_100: jmethodID?

    open func setBlob( parameterIndex: Int, inputStream: /* java.io.InputStream */ UnclassedObject?, length: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: inputStream != nil ? inputStream! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBlob", methodSig: "(ILjava/io/InputStream;J)V", methodCache: &PreparedStatementForward.setBlob_MethodID_100, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBlob( _ _parameterIndex: Int, _ _inputStream: /* java.io.InputStream */ UnclassedObject?, _ _length: Int64 ) throws /* java.sql.SQLException */ {
        try setBlob( parameterIndex: _parameterIndex, inputStream: _inputStream, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.setBlob(int,java.io.InputStream) throws java.sql.SQLException

    private static var setBlob_MethodID_101: jmethodID?

    open func setBlob( parameterIndex: Int, inputStream: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: inputStream != nil ? inputStream! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBlob", methodSig: "(ILjava/io/InputStream;)V", methodCache: &PreparedStatementForward.setBlob_MethodID_101, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBlob( _ _parameterIndex: Int, _ _inputStream: /* java.io.InputStream */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setBlob( parameterIndex: _parameterIndex, inputStream: _inputStream )
    }

    /// public abstract void java.sql.PreparedStatement.setBlob(int,java.sql.Blob) throws java.sql.SQLException

    private static var setBlob_MethodID_102: jmethodID?

    open func setBlob( parameterIndex: Int, x: Blob? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setBlob", methodSig: "(ILjava/sql/Blob;)V", methodCache: &PreparedStatementForward.setBlob_MethodID_102, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setBlob( _ _parameterIndex: Int, _ _x: Blob? ) throws /* java.sql.SQLException */ {
        try setBlob( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setSQLXML(int,java.sql.SQLXML) throws java.sql.SQLException

    private static var setSQLXML_MethodID_103: jmethodID?

    open func setSQLXML( parameterIndex: Int, xmlObject: SQLXML? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: xmlObject, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setSQLXML", methodSig: "(ILjava/sql/SQLXML;)V", methodCache: &PreparedStatementForward.setSQLXML_MethodID_103, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setSQLXML( _ _parameterIndex: Int, _ _xmlObject: SQLXML? ) throws /* java.sql.SQLException */ {
        try setSQLXML( parameterIndex: _parameterIndex, xmlObject: _xmlObject )
    }

    /// public abstract java.sql.ResultSet java.sql.PreparedStatement.executeQuery() throws java.sql.SQLException

    private static var executeQuery_MethodID_104: jmethodID?

    open func executeQuery() throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeQuery", methodSig: "()Ljava/sql/ResultSet;", methodCache: &PreparedStatementForward.executeQuery_MethodID_104, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.PreparedStatement.executeUpdate() throws java.sql.SQLException

    private static var executeUpdate_MethodID_105: jmethodID?

    open func executeUpdate() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "()I", methodCache: &PreparedStatementForward.executeUpdate_MethodID_105, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.PreparedStatement.setUnicodeStream(int,java.io.InputStream,int) throws java.sql.SQLException

    private static var setUnicodeStream_MethodID_106: jmethodID?

    open func setUnicodeStream( parameterIndex: Int, x: /* java.io.InputStream */ UnclassedObject?, length: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: length, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setUnicodeStream", methodSig: "(ILjava/io/InputStream;I)V", methodCache: &PreparedStatementForward.setUnicodeStream_MethodID_106, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setUnicodeStream( _ _parameterIndex: Int, _ _x: /* java.io.InputStream */ UnclassedObject?, _ _length: Int ) throws /* java.sql.SQLException */ {
        try setUnicodeStream( parameterIndex: _parameterIndex, x: _x, length: _length )
    }

    /// public abstract void java.sql.PreparedStatement.clearParameters() throws java.sql.SQLException

    private static var clearParameters_MethodID_107: jmethodID?

    open func clearParameters() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearParameters", methodSig: "()V", methodCache: &PreparedStatementForward.clearParameters_MethodID_107, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.PreparedStatement.addBatch() throws java.sql.SQLException

    private static var addBatch_MethodID_108: jmethodID?

    open func addBatch() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addBatch", methodSig: "()V", methodCache: &PreparedStatementForward.addBatch_MethodID_108, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.PreparedStatement.setRef(int,java.sql.Ref) throws java.sql.SQLException

    private static var setRef_MethodID_109: jmethodID?

    open func setRef( parameterIndex: Int, x: Ref? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setRef", methodSig: "(ILjava/sql/Ref;)V", methodCache: &PreparedStatementForward.setRef_MethodID_109, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setRef( _ _parameterIndex: Int, _ _x: Ref? ) throws /* java.sql.SQLException */ {
        try setRef( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setArray(int,java.sql.Array) throws java.sql.SQLException

    private static var setArray_MethodID_110: jmethodID?

    open func setArray( parameterIndex: Int, x: Array? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setArray", methodSig: "(ILjava/sql/Array;)V", methodCache: &PreparedStatementForward.setArray_MethodID_110, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setArray( _ _parameterIndex: Int, _ _x: Array? ) throws /* java.sql.SQLException */ {
        try setArray( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract java.sql.ParameterMetaData java.sql.PreparedStatement.getParameterMetaData() throws java.sql.SQLException

    private static var getParameterMetaData_MethodID_111: jmethodID?

    open func getParameterMetaData() throws /* java.sql.SQLException */ -> ParameterMetaData! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getParameterMetaData", methodSig: "()Ljava/sql/ParameterMetaData;", methodCache: &PreparedStatementForward.getParameterMetaData_MethodID_111, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ParameterMetaDataForward( javaObject: __return ) : nil
    }


    /// public default long java.sql.PreparedStatement.executeLargeUpdate() throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_112: jmethodID?

    open func executeLargeUpdate() throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "()J", methodCache: &PreparedStatementForward.executeLargeUpdate_MethodID_112, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public abstract java.sql.ResultSetMetaData java.sql.PreparedStatement.getMetaData() throws java.sql.SQLException

    private static var getMetaData_MethodID_113: jmethodID?

    open func getMetaData() throws /* java.sql.SQLException */ -> ResultSetMetaData! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getMetaData", methodSig: "()Ljava/sql/ResultSetMetaData;", methodCache: &PreparedStatementForward.getMetaData_MethodID_113, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetMetaDataForward( javaObject: __return ) : nil
    }


    /// public abstract void java.sql.PreparedStatement.setURL(int,java.net.URL) throws java.sql.SQLException

    private static var setURL_MethodID_114: jmethodID?

    open func setURL( parameterIndex: Int, x: /* java.net.URL */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setURL", methodSig: "(ILjava/net/URL;)V", methodCache: &PreparedStatementForward.setURL_MethodID_114, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setURL( _ _parameterIndex: Int, _ _x: /* java.net.URL */ UnclassedObject? ) throws /* java.sql.SQLException */ {
        try setURL( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setTime(int,java.sql.Time) throws java.sql.SQLException

    private static var setTime_MethodID_115: jmethodID?

    open func setTime( parameterIndex: Int, x: Time? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTime", methodSig: "(ILjava/sql/Time;)V", methodCache: &PreparedStatementForward.setTime_MethodID_115, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setTime( _ _parameterIndex: Int, _ _x: Time? ) throws /* java.sql.SQLException */ {
        try setTime( parameterIndex: _parameterIndex, x: _x )
    }

    /// public abstract void java.sql.PreparedStatement.setTime(int,java.sql.Time,java.util.Calendar) throws java.sql.SQLException

    private static var setTime_MethodID_116: jmethodID?

    open func setTime( parameterIndex: Int, x: Time?, cal: java_util.Calendar? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: parameterIndex, locals: &__locals )
        __args[1] = JNIType.toJava( value: x != nil ? x! as JNIObject : nil, locals: &__locals )
        __args[2] = JNIType.toJava( value: cal != nil ? cal! as JNIObject : nil, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTime", methodSig: "(ILjava/sql/Time;Ljava/util/Calendar;)V", methodCache: &PreparedStatementForward.setTime_MethodID_116, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setTime( _ _parameterIndex: Int, _ _x: Time?, _ _cal: java_util.Calendar? ) throws /* java.sql.SQLException */ {
        try setTime( parameterIndex: _parameterIndex, x: _x, cal: _cal )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int) throws java.sql.SQLException

    private static var execute_MethodID_117: jmethodID?

    override open func execute( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: autoGeneratedKeys, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;I)Z", methodCache: &PreparedStatementForward.execute_MethodID_117, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func execute( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String) throws java.sql.SQLException

    private static var execute_MethodID_118: jmethodID?

    override open func execute( sql: String? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;)Z", methodCache: &PreparedStatementForward.execute_MethodID_118, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func execute( _ _sql: String? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var execute_MethodID_119: jmethodID?

    override open func execute( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)Z", methodCache: &PreparedStatementForward.execute_MethodID_119, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func execute( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql, columnNames: _columnNames )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int[]) throws java.sql.SQLException

    private static var execute_MethodID_120: jmethodID?

    override open func execute( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;[I)Z", methodCache: &PreparedStatementForward.execute_MethodID_120, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func execute( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public abstract void java.sql.Statement.close() throws java.sql.SQLException

    private static var close_MethodID_121: jmethodID?

    override open func close() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &PreparedStatementForward.close_MethodID_121, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.executeQuery(java.lang.String) throws java.sql.SQLException

    private static var executeQuery_MethodID_122: jmethodID?

    override open func executeQuery( sql: String? ) throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeQuery", methodSig: "(Ljava/lang/String;)Ljava/sql/ResultSet;", methodCache: &PreparedStatementForward.executeQuery_MethodID_122, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }

    override open func executeQuery( _ _sql: String? ) throws /* java.sql.SQLException */ -> ResultSet! {
        return try executeQuery( sql: _sql )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    private static var executeUpdate_MethodID_123: jmethodID?

    override open func executeUpdate( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;[I)I", methodCache: &PreparedStatementForward.executeUpdate_MethodID_123, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }

    override open func executeUpdate( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var executeUpdate_MethodID_124: jmethodID?

    override open func executeUpdate( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)I", methodCache: &PreparedStatementForward.executeUpdate_MethodID_124, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }

    override open func executeUpdate( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql, columnNames: _columnNames )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int) throws java.sql.SQLException

    private static var executeUpdate_MethodID_125: jmethodID?

    override open func executeUpdate( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: autoGeneratedKeys, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;I)I", methodCache: &PreparedStatementForward.executeUpdate_MethodID_125, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }

    override open func executeUpdate( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String) throws java.sql.SQLException

    private static var executeUpdate_MethodID_126: jmethodID?

    override open func executeUpdate( sql: String? ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;)I", methodCache: &PreparedStatementForward.executeUpdate_MethodID_126, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }

    override open func executeUpdate( _ _sql: String? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql )
    }

    /// public abstract void java.sql.Statement.addBatch(java.lang.String) throws java.sql.SQLException

    private static var addBatch_MethodID_127: jmethodID?

    override open func addBatch( sql: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addBatch", methodSig: "(Ljava/lang/String;)V", methodCache: &PreparedStatementForward.addBatch_MethodID_127, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func addBatch( _ _sql: String? ) throws /* java.sql.SQLException */ {
        try addBatch( sql: _sql )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_128: jmethodID?

    override open func executeLargeUpdate( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;[I)J", methodCache: &PreparedStatementForward.executeLargeUpdate_MethodID_128, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    override open func executeLargeUpdate( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_129: jmethodID?

    override open func executeLargeUpdate( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)J", methodCache: &PreparedStatementForward.executeLargeUpdate_MethodID_129, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    override open func executeLargeUpdate( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql, columnNames: _columnNames )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,int) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_130: jmethodID?

    override open func executeLargeUpdate( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: autoGeneratedKeys, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;I)J", methodCache: &PreparedStatementForward.executeLargeUpdate_MethodID_130, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    override open func executeLargeUpdate( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_131: jmethodID?

    override open func executeLargeUpdate( sql: String? ) throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;)J", methodCache: &PreparedStatementForward.executeLargeUpdate_MethodID_131, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    override open func executeLargeUpdate( _ _sql: String? ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql )
    }

    /// public abstract int java.sql.Statement.getMaxFieldSize() throws java.sql.SQLException

    private static var getMaxFieldSize_MethodID_132: jmethodID?

    override open func getMaxFieldSize() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMaxFieldSize", methodSig: "()I", methodCache: &PreparedStatementForward.getMaxFieldSize_MethodID_132, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setMaxFieldSize(int) throws java.sql.SQLException

    private static var setMaxFieldSize_MethodID_133: jmethodID?

    override open func setMaxFieldSize( max: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: max, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setMaxFieldSize", methodSig: "(I)V", methodCache: &PreparedStatementForward.setMaxFieldSize_MethodID_133, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setMaxFieldSize( _ _max: Int ) throws /* java.sql.SQLException */ {
        try setMaxFieldSize( max: _max )
    }

    /// public abstract int java.sql.Statement.getMaxRows() throws java.sql.SQLException

    private static var getMaxRows_MethodID_134: jmethodID?

    override open func getMaxRows() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMaxRows", methodSig: "()I", methodCache: &PreparedStatementForward.getMaxRows_MethodID_134, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setMaxRows(int) throws java.sql.SQLException

    private static var setMaxRows_MethodID_135: jmethodID?

    override open func setMaxRows( max: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: max, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setMaxRows", methodSig: "(I)V", methodCache: &PreparedStatementForward.setMaxRows_MethodID_135, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setMaxRows( _ _max: Int ) throws /* java.sql.SQLException */ {
        try setMaxRows( max: _max )
    }

    /// public abstract void java.sql.Statement.setEscapeProcessing(boolean) throws java.sql.SQLException

    private static var setEscapeProcessing_MethodID_136: jmethodID?

    override open func setEscapeProcessing( enable: Bool ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: enable, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setEscapeProcessing", methodSig: "(Z)V", methodCache: &PreparedStatementForward.setEscapeProcessing_MethodID_136, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setEscapeProcessing( _ _enable: Bool ) throws /* java.sql.SQLException */ {
        try setEscapeProcessing( enable: _enable )
    }

    /// public abstract int java.sql.Statement.getQueryTimeout() throws java.sql.SQLException

    private static var getQueryTimeout_MethodID_137: jmethodID?

    override open func getQueryTimeout() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getQueryTimeout", methodSig: "()I", methodCache: &PreparedStatementForward.getQueryTimeout_MethodID_137, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setQueryTimeout(int) throws java.sql.SQLException

    private static var setQueryTimeout_MethodID_138: jmethodID?

    override open func setQueryTimeout( seconds: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: seconds, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setQueryTimeout", methodSig: "(I)V", methodCache: &PreparedStatementForward.setQueryTimeout_MethodID_138, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setQueryTimeout( _ _seconds: Int ) throws /* java.sql.SQLException */ {
        try setQueryTimeout( seconds: _seconds )
    }

    /// public abstract void java.sql.Statement.cancel() throws java.sql.SQLException

    private static var cancel_MethodID_139: jmethodID?

    override open func cancel() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "cancel", methodSig: "()V", methodCache: &PreparedStatementForward.cancel_MethodID_139, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.setCursorName(java.lang.String) throws java.sql.SQLException

    private static var setCursorName_MethodID_140: jmethodID?

    override open func setCursorName( name: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCursorName", methodSig: "(Ljava/lang/String;)V", methodCache: &PreparedStatementForward.setCursorName_MethodID_140, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setCursorName( _ _name: String? ) throws /* java.sql.SQLException */ {
        try setCursorName( name: _name )
    }

    /// public abstract int java.sql.Statement.getUpdateCount() throws java.sql.SQLException

    private static var getUpdateCount_MethodID_141: jmethodID?

    override open func getUpdateCount() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getUpdateCount", methodSig: "()I", methodCache: &PreparedStatementForward.getUpdateCount_MethodID_141, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract boolean java.sql.Statement.getMoreResults(int) throws java.sql.SQLException

    private static var getMoreResults_MethodID_142: jmethodID?

    override open func getMoreResults( current: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: current, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getMoreResults", methodSig: "(I)Z", methodCache: &PreparedStatementForward.getMoreResults_MethodID_142, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func getMoreResults( _ _current: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try getMoreResults( current: _current )
    }

    /// public abstract boolean java.sql.Statement.getMoreResults() throws java.sql.SQLException

    private static var getMoreResults_MethodID_143: jmethodID?

    override open func getMoreResults() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getMoreResults", methodSig: "()Z", methodCache: &PreparedStatementForward.getMoreResults_MethodID_143, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public abstract int java.sql.Statement.getResultSetConcurrency() throws java.sql.SQLException

    private static var getResultSetConcurrency_MethodID_144: jmethodID?

    override open func getResultSetConcurrency() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetConcurrency", methodSig: "()I", methodCache: &PreparedStatementForward.getResultSetConcurrency_MethodID_144, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract int java.sql.Statement.getResultSetType() throws java.sql.SQLException

    private static var getResultSetType_MethodID_145: jmethodID?

    override open func getResultSetType() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetType", methodSig: "()I", methodCache: &PreparedStatementForward.getResultSetType_MethodID_145, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.clearBatch() throws java.sql.SQLException

    private static var clearBatch_MethodID_146: jmethodID?

    override open func clearBatch() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearBatch", methodSig: "()V", methodCache: &PreparedStatementForward.clearBatch_MethodID_146, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract int[] java.sql.Statement.executeBatch() throws java.sql.SQLException

    private static var executeBatch_MethodID_147: jmethodID?

    override open func executeBatch() throws /* java.sql.SQLException */ -> [Int32]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeBatch", methodSig: "()[I", methodCache: &PreparedStatementForward.executeBatch_MethodID_147, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: [Int32](), from: __return )
    }


    /// public abstract java.sql.Connection java.sql.Statement.getConnection() throws java.sql.SQLException

    private static var getConnection_MethodID_148: jmethodID?

    override open func getConnection() throws /* java.sql.SQLException */ -> Connection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConnection", methodSig: "()Ljava/sql/Connection;", methodCache: &PreparedStatementForward.getConnection_MethodID_148, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ConnectionForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.getGeneratedKeys() throws java.sql.SQLException

    private static var getGeneratedKeys_MethodID_149: jmethodID?

    override open func getGeneratedKeys() throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGeneratedKeys", methodSig: "()Ljava/sql/ResultSet;", methodCache: &PreparedStatementForward.getGeneratedKeys_MethodID_149, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.Statement.getResultSetHoldability() throws java.sql.SQLException

    private static var getResultSetHoldability_MethodID_150: jmethodID?

    override open func getResultSetHoldability() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetHoldability", methodSig: "()I", methodCache: &PreparedStatementForward.getResultSetHoldability_MethodID_150, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setPoolable(boolean) throws java.sql.SQLException

    private static var setPoolable_MethodID_151: jmethodID?

    override open func setPoolable( poolable: Bool ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: poolable, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setPoolable", methodSig: "(Z)V", methodCache: &PreparedStatementForward.setPoolable_MethodID_151, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setPoolable( _ _poolable: Bool ) throws /* java.sql.SQLException */ {
        try setPoolable( poolable: _poolable )
    }

    /// public abstract boolean java.sql.Statement.isPoolable() throws java.sql.SQLException

    private static var isPoolable_MethodID_152: jmethodID?

    override open func isPoolable() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isPoolable", methodSig: "()Z", methodCache: &PreparedStatementForward.isPoolable_MethodID_152, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public abstract void java.sql.Statement.closeOnCompletion() throws java.sql.SQLException

    private static var closeOnCompletion_MethodID_153: jmethodID?

    override open func closeOnCompletion() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "closeOnCompletion", methodSig: "()V", methodCache: &PreparedStatementForward.closeOnCompletion_MethodID_153, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract boolean java.sql.Statement.isCloseOnCompletion() throws java.sql.SQLException

    private static var isCloseOnCompletion_MethodID_154: jmethodID?

    override open func isCloseOnCompletion() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCloseOnCompletion", methodSig: "()Z", methodCache: &PreparedStatementForward.isCloseOnCompletion_MethodID_154, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public default long java.sql.Statement.getLargeUpdateCount() throws java.sql.SQLException

    private static var getLargeUpdateCount_MethodID_155: jmethodID?

    override open func getLargeUpdateCount() throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getLargeUpdateCount", methodSig: "()J", methodCache: &PreparedStatementForward.getLargeUpdateCount_MethodID_155, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public default void java.sql.Statement.setLargeMaxRows(long) throws java.sql.SQLException

    private static var setLargeMaxRows_MethodID_156: jmethodID?

    override open func setLargeMaxRows( max: Int64 ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: max, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLargeMaxRows", methodSig: "(J)V", methodCache: &PreparedStatementForward.setLargeMaxRows_MethodID_156, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setLargeMaxRows( _ _max: Int64 ) throws /* java.sql.SQLException */ {
        try setLargeMaxRows( max: _max )
    }

    /// public default long java.sql.Statement.getLargeMaxRows() throws java.sql.SQLException

    private static var getLargeMaxRows_MethodID_157: jmethodID?

    override open func getLargeMaxRows() throws /* java.sql.SQLException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getLargeMaxRows", methodSig: "()J", methodCache: &PreparedStatementForward.getLargeMaxRows_MethodID_157, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public default long[] java.sql.Statement.executeLargeBatch() throws java.sql.SQLException

    private static var executeLargeBatch_MethodID_158: jmethodID?

    override open func executeLargeBatch() throws /* java.sql.SQLException */ -> [Int64]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeLargeBatch", methodSig: "()[J", methodCache: &PreparedStatementForward.executeLargeBatch_MethodID_158, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: [Int64](), from: __return )
    }


    /// public abstract java.sql.SQLWarning java.sql.Statement.getWarnings() throws java.sql.SQLException

    private static var getWarnings_MethodID_159: jmethodID?

    override open func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getWarnings", methodSig: "()Ljava/sql/SQLWarning;", methodCache: &PreparedStatementForward.getWarnings_MethodID_159, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SQLWarning( javaObject: __return ) : nil
    }


    /// public abstract void java.sql.Statement.clearWarnings() throws java.sql.SQLException

    private static var clearWarnings_MethodID_160: jmethodID?

    override open func clearWarnings() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearWarnings", methodSig: "()V", methodCache: &PreparedStatementForward.clearWarnings_MethodID_160, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.setFetchDirection(int) throws java.sql.SQLException

    private static var setFetchDirection_MethodID_161: jmethodID?

    override open func setFetchDirection( direction: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: direction, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFetchDirection", methodSig: "(I)V", methodCache: &PreparedStatementForward.setFetchDirection_MethodID_161, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setFetchDirection( _ _direction: Int ) throws /* java.sql.SQLException */ {
        try setFetchDirection( direction: _direction )
    }

    /// public abstract int java.sql.Statement.getFetchDirection() throws java.sql.SQLException

    private static var getFetchDirection_MethodID_162: jmethodID?

    override open func getFetchDirection() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getFetchDirection", methodSig: "()I", methodCache: &PreparedStatementForward.getFetchDirection_MethodID_162, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setFetchSize(int) throws java.sql.SQLException

    private static var setFetchSize_MethodID_163: jmethodID?

    override open func setFetchSize( rows: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: rows, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFetchSize", methodSig: "(I)V", methodCache: &PreparedStatementForward.setFetchSize_MethodID_163, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    override open func setFetchSize( _ _rows: Int ) throws /* java.sql.SQLException */ {
        try setFetchSize( rows: _rows )
    }

    /// public abstract int java.sql.Statement.getFetchSize() throws java.sql.SQLException

    private static var getFetchSize_MethodID_164: jmethodID?

    override open func getFetchSize() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getFetchSize", methodSig: "()I", methodCache: &PreparedStatementForward.getFetchSize_MethodID_164, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract boolean java.sql.Statement.isClosed() throws java.sql.SQLException

    private static var isClosed_MethodID_165: jmethodID?

    override open func isClosed() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isClosed", methodSig: "()Z", methodCache: &PreparedStatementForward.isClosed_MethodID_165, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.getResultSet() throws java.sql.SQLException

    private static var getResultSet_MethodID_166: jmethodID?

    override open func getResultSet() throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResultSet", methodSig: "()Ljava/sql/ResultSet;", methodCache: &PreparedStatementForward.getResultSet_MethodID_166, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public abstract java.lang.Object java.sql.Wrapper.unwrap(java.lang.Class) throws java.sql.SQLException

    private static var unwrap_MethodID_167: jmethodID?

    override open func unwrap( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: iface != nil ? iface! as JNIObject : nil, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unwrap", methodSig: "(Ljava/lang/Class;)Ljava/lang/Object;", methodCache: &PreparedStatementForward.unwrap_MethodID_167, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    override open func unwrap( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        return try unwrap( iface: _iface )
    }

    /// public abstract boolean java.sql.Wrapper.isWrapperFor(java.lang.Class) throws java.sql.SQLException

    private static var isWrapperFor_MethodID_168: jmethodID?

    override open func isWrapperFor( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: iface != nil ? iface! as JNIObject : nil, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isWrapperFor", methodSig: "(Ljava/lang/Class;)Z", methodCache: &PreparedStatementForward.isWrapperFor_MethodID_168, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: Bool(), from: __return )
    }

    override open func isWrapperFor( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        return try isWrapperFor( iface: _iface )
    }

}


