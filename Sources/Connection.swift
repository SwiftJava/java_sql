
import java_swift
import java_lang
import java_util

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.sql.Connection ///

public protocol Connection: Wrapper, java_lang.AutoCloseable {

    /// public static final int java.sql.Connection.TRANSACTION_NONE

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Connection.TRANSACTION_READ_COMMITTED

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Connection.TRANSACTION_READ_UNCOMMITTED

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Connection.TRANSACTION_REPEATABLE_READ

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Connection.TRANSACTION_SERIALIZABLE

    // Skipping field: false false false false false true 

    /// public abstract void java.sql.Connection.abort(java.util.concurrent.Executor) throws java.sql.SQLException

    func abort( executor: java_util.Executor? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.clearWarnings() throws java.sql.SQLException

    func clearWarnings() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.close() throws java.sql.SQLException

    func close() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.commit() throws java.sql.SQLException

    func commit() throws /* java.sql.SQLException */

    /// public abstract java.sql.Array java.sql.Connection.createArrayOf(java.lang.String,java.lang.Object[]) throws java.sql.SQLException

    func createArrayOf( typeName: String?, elements: [JavaObject]? ) throws /* java.sql.SQLException */ -> Array!

    /// public abstract java.sql.Blob java.sql.Connection.createBlob() throws java.sql.SQLException

    func createBlob() throws /* java.sql.SQLException */ -> Blob!

    /// public abstract java.sql.Clob java.sql.Connection.createClob() throws java.sql.SQLException

    func createClob() throws /* java.sql.SQLException */ -> Clob!

    /// public abstract java.sql.NClob java.sql.Connection.createNClob() throws java.sql.SQLException

    func createNClob() throws /* java.sql.SQLException */ -> NClob!

    /// public abstract java.sql.SQLXML java.sql.Connection.createSQLXML() throws java.sql.SQLException

    func createSQLXML() throws /* java.sql.SQLException */ -> SQLXML!

    /// public abstract java.sql.Statement java.sql.Connection.createStatement(int,int) throws java.sql.SQLException

    func createStatement( resultSetType: Int, resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> Statement!

    /// public abstract java.sql.Statement java.sql.Connection.createStatement(int,int,int) throws java.sql.SQLException

    func createStatement( resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> Statement!

    /// public abstract java.sql.Statement java.sql.Connection.createStatement() throws java.sql.SQLException

    func createStatement() throws /* java.sql.SQLException */ -> Statement!

    /// public abstract java.sql.Struct java.sql.Connection.createStruct(java.lang.String,java.lang.Object[]) throws java.sql.SQLException

    func createStruct( typeName: String?, attributes: [JavaObject]? ) throws /* java.sql.SQLException */ -> Struct!

    /// public abstract boolean java.sql.Connection.getAutoCommit() throws java.sql.SQLException

    func getAutoCommit() throws /* java.sql.SQLException */ -> Bool

    /// public abstract java.lang.String java.sql.Connection.getCatalog() throws java.sql.SQLException

    func getCatalog() throws /* java.sql.SQLException */ -> String!

    /// public abstract java.lang.String java.sql.Connection.getClientInfo(java.lang.String) throws java.sql.SQLException

    func getClientInfo( name: String? ) throws /* java.sql.SQLException */ -> String!

    /// public abstract java.util.Properties java.sql.Connection.getClientInfo() throws java.sql.SQLException

    func getClientInfo() throws /* java.sql.SQLException */ -> java_util.Properties!

    /// public abstract int java.sql.Connection.getHoldability() throws java.sql.SQLException

    func getHoldability() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.sql.DatabaseMetaData java.sql.Connection.getMetaData() throws java.sql.SQLException

    func getMetaData() throws /* java.sql.SQLException */ -> DatabaseMetaData!

    /// public abstract int java.sql.Connection.getNetworkTimeout() throws java.sql.SQLException

    func getNetworkTimeout() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.lang.String java.sql.Connection.getSchema() throws java.sql.SQLException

    func getSchema() throws /* java.sql.SQLException */ -> String!

    /// public abstract int java.sql.Connection.getTransactionIsolation() throws java.sql.SQLException

    func getTransactionIsolation() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.util.Map java.sql.Connection.getTypeMap() throws java.sql.SQLException

    func getTypeMap() throws /* java.sql.SQLException */ -> java_swift.JavaMap!

    /// public abstract java.sql.SQLWarning java.sql.Connection.getWarnings() throws java.sql.SQLException

    func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning!

    /// public abstract boolean java.sql.Connection.isClosed() throws java.sql.SQLException

    func isClosed() throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Connection.isReadOnly() throws java.sql.SQLException

    func isReadOnly() throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Connection.isValid(int) throws java.sql.SQLException

    func isValid( timeout: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract java.lang.String java.sql.Connection.nativeSQL(java.lang.String) throws java.sql.SQLException

    func nativeSQL( sql: String? ) throws /* java.sql.SQLException */ -> String!

    /// public abstract java.sql.CallableStatement java.sql.Connection.prepareCall(java.lang.String) throws java.sql.SQLException

    func prepareCall( sql: String? ) throws /* java.sql.SQLException */ -> CallableStatement!

    /// public abstract java.sql.CallableStatement java.sql.Connection.prepareCall(java.lang.String,int,int) throws java.sql.SQLException

    func prepareCall( sql: String?, resultSetType: Int, resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> CallableStatement!

    /// public abstract java.sql.CallableStatement java.sql.Connection.prepareCall(java.lang.String,int,int,int) throws java.sql.SQLException

    func prepareCall( sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> CallableStatement!

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String) throws java.sql.SQLException

    func prepareStatement( sql: String? ) throws /* java.sql.SQLException */ -> PreparedStatement!

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int) throws java.sql.SQLException

    func prepareStatement( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> PreparedStatement!

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int) throws java.sql.SQLException

    func prepareStatement( sql: String?, resultSetType: Int, resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> PreparedStatement!

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int,int) throws java.sql.SQLException

    func prepareStatement( sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> PreparedStatement!

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int[]) throws java.sql.SQLException

    func prepareStatement( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> PreparedStatement!

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    func prepareStatement( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> PreparedStatement!

    /// public abstract void java.sql.Connection.releaseSavepoint(java.sql.Savepoint) throws java.sql.SQLException

    func releaseSavepoint( savepoint: Savepoint? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.rollback(java.sql.Savepoint) throws java.sql.SQLException

    func rollback( savepoint: Savepoint? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.rollback() throws java.sql.SQLException

    func rollback() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setAutoCommit(boolean) throws java.sql.SQLException

    func setAutoCommit( autoCommit: Bool ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setCatalog(java.lang.String) throws java.sql.SQLException

    func setCatalog( catalog: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setClientInfo(java.lang.String,java.lang.String) throws java.sql.SQLClientInfoException

    func setClientInfo( name: String?, value: String? ) throws /* java.sql.SQLClientInfoException */

    /// public abstract void java.sql.Connection.setClientInfo(java.util.Properties) throws java.sql.SQLClientInfoException

    func setClientInfo( properties: java_util.Properties? ) throws /* java.sql.SQLClientInfoException */

    /// public abstract void java.sql.Connection.setHoldability(int) throws java.sql.SQLException

    func setHoldability( holdability: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setNetworkTimeout(java.util.concurrent.Executor,int) throws java.sql.SQLException

    func setNetworkTimeout( executor: java_util.Executor?, milliseconds: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setReadOnly(boolean) throws java.sql.SQLException

    func setReadOnly( readOnly: Bool ) throws /* java.sql.SQLException */

    /// public abstract java.sql.Savepoint java.sql.Connection.setSavepoint(java.lang.String) throws java.sql.SQLException

    func setSavepoint( name: String? ) throws /* java.sql.SQLException */ -> Savepoint!

    /// public abstract java.sql.Savepoint java.sql.Connection.setSavepoint() throws java.sql.SQLException

    func setSavepoint() throws /* java.sql.SQLException */ -> Savepoint!

    /// public abstract void java.sql.Connection.setSchema(java.lang.String) throws java.sql.SQLException

    func setSchema( schema: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setTransactionIsolation(int) throws java.sql.SQLException

    func setTransactionIsolation( level: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Connection.setTypeMap(java.util.Map) throws java.sql.SQLException

    func setTypeMap( map: java_swift.JavaMap? ) throws /* java.sql.SQLException */

}


open class ConnectionForward: WrapperForward, Connection {

    private static var ConnectionJNIClass: jclass?

    /// public static final int java.sql.Connection.TRANSACTION_NONE

    private static var TRANSACTION_NONE_FieldID: jfieldID?

    public static var TRANSACTION_NONE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "TRANSACTION_NONE", fieldType: "I", fieldCache: &TRANSACTION_NONE_FieldID, className: "java/sql/Connection", classCache: &ConnectionJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Connection.TRANSACTION_READ_COMMITTED

    private static var TRANSACTION_READ_COMMITTED_FieldID: jfieldID?

    public static var TRANSACTION_READ_COMMITTED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "TRANSACTION_READ_COMMITTED", fieldType: "I", fieldCache: &TRANSACTION_READ_COMMITTED_FieldID, className: "java/sql/Connection", classCache: &ConnectionJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Connection.TRANSACTION_READ_UNCOMMITTED

    private static var TRANSACTION_READ_UNCOMMITTED_FieldID: jfieldID?

    public static var TRANSACTION_READ_UNCOMMITTED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "TRANSACTION_READ_UNCOMMITTED", fieldType: "I", fieldCache: &TRANSACTION_READ_UNCOMMITTED_FieldID, className: "java/sql/Connection", classCache: &ConnectionJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Connection.TRANSACTION_REPEATABLE_READ

    private static var TRANSACTION_REPEATABLE_READ_FieldID: jfieldID?

    public static var TRANSACTION_REPEATABLE_READ: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "TRANSACTION_REPEATABLE_READ", fieldType: "I", fieldCache: &TRANSACTION_REPEATABLE_READ_FieldID, className: "java/sql/Connection", classCache: &ConnectionJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Connection.TRANSACTION_SERIALIZABLE

    private static var TRANSACTION_SERIALIZABLE_FieldID: jfieldID?

    public static var TRANSACTION_SERIALIZABLE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "TRANSACTION_SERIALIZABLE", fieldType: "I", fieldCache: &TRANSACTION_SERIALIZABLE_FieldID, className: "java/sql/Connection", classCache: &ConnectionJNIClass )
            return Int(__value)
        }
    }

    /// public abstract void java.sql.Connection.abort(java.util.concurrent.Executor) throws java.sql.SQLException

    private static var abort_MethodID_53: jmethodID?

    open func abort( executor: java_util.Executor? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: executor, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "abort", methodSig: "(Ljava/util/concurrent/Executor;)V", methodCache: &ConnectionForward.abort_MethodID_53, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func abort( _ _executor: java_util.Executor? ) throws /* java.sql.SQLException */ {
        try abort( executor: _executor )
    }

    /// public abstract void java.sql.Connection.clearWarnings() throws java.sql.SQLException

    private static var clearWarnings_MethodID_54: jmethodID?

    open func clearWarnings() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearWarnings", methodSig: "()V", methodCache: &ConnectionForward.clearWarnings_MethodID_54, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Connection.close() throws java.sql.SQLException

    private static var close_MethodID_55: jmethodID?

    open func close() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &ConnectionForward.close_MethodID_55, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Connection.commit() throws java.sql.SQLException

    private static var commit_MethodID_56: jmethodID?

    open func commit() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "commit", methodSig: "()V", methodCache: &ConnectionForward.commit_MethodID_56, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract java.sql.Array java.sql.Connection.createArrayOf(java.lang.String,java.lang.Object[]) throws java.sql.SQLException

    private static var createArrayOf_MethodID_57: jmethodID?

    open func createArrayOf( typeName: String?, elements: [JavaObject]? ) throws /* java.sql.SQLException */ -> Array! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: typeName, locals: &__locals )
        __args[1] = JNIType.toJava( value: elements, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createArrayOf", methodSig: "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/sql/Array;", methodCache: &ConnectionForward.createArrayOf_MethodID_57, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ArrayForward( javaObject: __return ) : nil
    }

    open func createArrayOf( _ _typeName: String?, _ _elements: [JavaObject]? ) throws /* java.sql.SQLException */ -> Array! {
        return try createArrayOf( typeName: _typeName, elements: _elements )
    }

    /// public abstract java.sql.Blob java.sql.Connection.createBlob() throws java.sql.SQLException

    private static var createBlob_MethodID_58: jmethodID?

    open func createBlob() throws /* java.sql.SQLException */ -> Blob! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createBlob", methodSig: "()Ljava/sql/Blob;", methodCache: &ConnectionForward.createBlob_MethodID_58, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? BlobForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.Clob java.sql.Connection.createClob() throws java.sql.SQLException

    private static var createClob_MethodID_59: jmethodID?

    open func createClob() throws /* java.sql.SQLException */ -> Clob! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createClob", methodSig: "()Ljava/sql/Clob;", methodCache: &ConnectionForward.createClob_MethodID_59, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ClobForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.NClob java.sql.Connection.createNClob() throws java.sql.SQLException

    private static var createNClob_MethodID_60: jmethodID?

    open func createNClob() throws /* java.sql.SQLException */ -> NClob! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createNClob", methodSig: "()Ljava/sql/NClob;", methodCache: &ConnectionForward.createNClob_MethodID_60, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? NClobForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.SQLXML java.sql.Connection.createSQLXML() throws java.sql.SQLException

    private static var createSQLXML_MethodID_61: jmethodID?

    open func createSQLXML() throws /* java.sql.SQLException */ -> SQLXML! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createSQLXML", methodSig: "()Ljava/sql/SQLXML;", methodCache: &ConnectionForward.createSQLXML_MethodID_61, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SQLXMLForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.Statement java.sql.Connection.createStatement(int,int) throws java.sql.SQLException

    private static var createStatement_MethodID_62: jmethodID?

    open func createStatement( resultSetType: Int, resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> Statement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = jvalue( i: jint(resultSetType) )
        __args[1] = jvalue( i: jint(resultSetConcurrency) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createStatement", methodSig: "(II)Ljava/sql/Statement;", methodCache: &ConnectionForward.createStatement_MethodID_62, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? StatementForward( javaObject: __return ) : nil
    }

    open func createStatement( _ _resultSetType: Int, _ _resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> Statement! {
        return try createStatement( resultSetType: _resultSetType, resultSetConcurrency: _resultSetConcurrency )
    }

    /// public abstract java.sql.Statement java.sql.Connection.createStatement(int,int,int) throws java.sql.SQLException

    private static var createStatement_MethodID_63: jmethodID?

    open func createStatement( resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> Statement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = jvalue( i: jint(resultSetType) )
        __args[1] = jvalue( i: jint(resultSetConcurrency) )
        __args[2] = jvalue( i: jint(resultSetHoldability) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createStatement", methodSig: "(III)Ljava/sql/Statement;", methodCache: &ConnectionForward.createStatement_MethodID_63, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? StatementForward( javaObject: __return ) : nil
    }

    open func createStatement( _ _resultSetType: Int, _ _resultSetConcurrency: Int, _ _resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> Statement! {
        return try createStatement( resultSetType: _resultSetType, resultSetConcurrency: _resultSetConcurrency, resultSetHoldability: _resultSetHoldability )
    }

    /// public abstract java.sql.Statement java.sql.Connection.createStatement() throws java.sql.SQLException

    private static var createStatement_MethodID_64: jmethodID?

    open func createStatement() throws /* java.sql.SQLException */ -> Statement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createStatement", methodSig: "()Ljava/sql/Statement;", methodCache: &ConnectionForward.createStatement_MethodID_64, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? StatementForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.Struct java.sql.Connection.createStruct(java.lang.String,java.lang.Object[]) throws java.sql.SQLException

    private static var createStruct_MethodID_65: jmethodID?

    open func createStruct( typeName: String?, attributes: [JavaObject]? ) throws /* java.sql.SQLException */ -> Struct! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: typeName, locals: &__locals )
        __args[1] = JNIType.toJava( value: attributes, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createStruct", methodSig: "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/sql/Struct;", methodCache: &ConnectionForward.createStruct_MethodID_65, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? StructForward( javaObject: __return ) : nil
    }

    open func createStruct( _ _typeName: String?, _ _attributes: [JavaObject]? ) throws /* java.sql.SQLException */ -> Struct! {
        return try createStruct( typeName: _typeName, attributes: _attributes )
    }

    /// public abstract boolean java.sql.Connection.getAutoCommit() throws java.sql.SQLException

    private static var getAutoCommit_MethodID_66: jmethodID?

    open func getAutoCommit() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getAutoCommit", methodSig: "()Z", methodCache: &ConnectionForward.getAutoCommit_MethodID_66, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract java.lang.String java.sql.Connection.getCatalog() throws java.sql.SQLException

    private static var getCatalog_MethodID_67: jmethodID?

    open func getCatalog() throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getCatalog", methodSig: "()Ljava/lang/String;", methodCache: &ConnectionForward.getCatalog_MethodID_67, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public abstract java.lang.String java.sql.Connection.getClientInfo(java.lang.String) throws java.sql.SQLException

    private static var getClientInfo_MethodID_68: jmethodID?

    open func getClientInfo( name: String? ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getClientInfo", methodSig: "(Ljava/lang/String;)Ljava/lang/String;", methodCache: &ConnectionForward.getClientInfo_MethodID_68, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getClientInfo( _ _name: String? ) throws /* java.sql.SQLException */ -> String! {
        return try getClientInfo( name: _name )
    }

    /// public abstract java.util.Properties java.sql.Connection.getClientInfo() throws java.sql.SQLException

    private static var getClientInfo_MethodID_69: jmethodID?

    open func getClientInfo() throws /* java.sql.SQLException */ -> java_util.Properties! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getClientInfo", methodSig: "()Ljava/util/Properties;", methodCache: &ConnectionForward.getClientInfo_MethodID_69, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: java_util.Properties.self, from: __return )
    }


    /// public abstract int java.sql.Connection.getHoldability() throws java.sql.SQLException

    private static var getHoldability_MethodID_70: jmethodID?

    open func getHoldability() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getHoldability", methodSig: "()I", methodCache: &ConnectionForward.getHoldability_MethodID_70, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract java.sql.DatabaseMetaData java.sql.Connection.getMetaData() throws java.sql.SQLException

    private static var getMetaData_MethodID_71: jmethodID?

    open func getMetaData() throws /* java.sql.SQLException */ -> DatabaseMetaData! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getMetaData", methodSig: "()Ljava/sql/DatabaseMetaData;", methodCache: &ConnectionForward.getMetaData_MethodID_71, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? DatabaseMetaDataForward( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.Connection.getNetworkTimeout() throws java.sql.SQLException

    private static var getNetworkTimeout_MethodID_72: jmethodID?

    open func getNetworkTimeout() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getNetworkTimeout", methodSig: "()I", methodCache: &ConnectionForward.getNetworkTimeout_MethodID_72, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract java.lang.String java.sql.Connection.getSchema() throws java.sql.SQLException

    private static var getSchema_MethodID_73: jmethodID?

    open func getSchema() throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSchema", methodSig: "()Ljava/lang/String;", methodCache: &ConnectionForward.getSchema_MethodID_73, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.Connection.getTransactionIsolation() throws java.sql.SQLException

    private static var getTransactionIsolation_MethodID_74: jmethodID?

    open func getTransactionIsolation() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getTransactionIsolation", methodSig: "()I", methodCache: &ConnectionForward.getTransactionIsolation_MethodID_74, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract java.util.Map java.sql.Connection.getTypeMap() throws java.sql.SQLException

    private static var getTypeMap_MethodID_75: jmethodID?

    open func getTypeMap() throws /* java.sql.SQLException */ -> java_swift.JavaMap! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTypeMap", methodSig: "()Ljava/util/Map;", methodCache: &ConnectionForward.getTypeMap_MethodID_75, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: java_swift.JavaMapForward.self, from: __return )
    }


    /// public abstract java.sql.SQLWarning java.sql.Connection.getWarnings() throws java.sql.SQLException

    private static var getWarnings_MethodID_76: jmethodID?

    open func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getWarnings", methodSig: "()Ljava/sql/SQLWarning;", methodCache: &ConnectionForward.getWarnings_MethodID_76, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SQLWarning( javaObject: __return ) : nil
    }


    /// public abstract boolean java.sql.Connection.isClosed() throws java.sql.SQLException

    private static var isClosed_MethodID_77: jmethodID?

    open func isClosed() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isClosed", methodSig: "()Z", methodCache: &ConnectionForward.isClosed_MethodID_77, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.sql.Connection.isReadOnly() throws java.sql.SQLException

    private static var isReadOnly_MethodID_78: jmethodID?

    open func isReadOnly() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isReadOnly", methodSig: "()Z", methodCache: &ConnectionForward.isReadOnly_MethodID_78, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.sql.Connection.isValid(int) throws java.sql.SQLException

    private static var isValid_MethodID_79: jmethodID?

    open func isValid( timeout: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(timeout) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isValid", methodSig: "(I)Z", methodCache: &ConnectionForward.isValid_MethodID_79, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isValid( _ _timeout: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isValid( timeout: _timeout )
    }

    /// public abstract boolean java.sql.Wrapper.isWrapperFor(java.lang.Class) throws java.sql.SQLException

    private static var isWrapperFor_MethodID_80: jmethodID?

    override open func isWrapperFor( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: iface, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isWrapperFor", methodSig: "(Ljava/lang/Class;)Z", methodCache: &ConnectionForward.isWrapperFor_MethodID_80, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    override open func isWrapperFor( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        return try isWrapperFor( iface: _iface )
    }

    /// public abstract java.lang.String java.sql.Connection.nativeSQL(java.lang.String) throws java.sql.SQLException

    private static var nativeSQL_MethodID_81: jmethodID?

    open func nativeSQL( sql: String? ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "nativeSQL", methodSig: "(Ljava/lang/String;)Ljava/lang/String;", methodCache: &ConnectionForward.nativeSQL_MethodID_81, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func nativeSQL( _ _sql: String? ) throws /* java.sql.SQLException */ -> String! {
        return try nativeSQL( sql: _sql )
    }

    /// public abstract java.sql.CallableStatement java.sql.Connection.prepareCall(java.lang.String) throws java.sql.SQLException

    private static var prepareCall_MethodID_82: jmethodID?

    open func prepareCall( sql: String? ) throws /* java.sql.SQLException */ -> CallableStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareCall", methodSig: "(Ljava/lang/String;)Ljava/sql/CallableStatement;", methodCache: &ConnectionForward.prepareCall_MethodID_82, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? CallableStatementForward( javaObject: __return ) : nil
    }

    open func prepareCall( _ _sql: String? ) throws /* java.sql.SQLException */ -> CallableStatement! {
        return try prepareCall( sql: _sql )
    }

    /// public abstract java.sql.CallableStatement java.sql.Connection.prepareCall(java.lang.String,int,int) throws java.sql.SQLException

    private static var prepareCall_MethodID_83: jmethodID?

    open func prepareCall( sql: String?, resultSetType: Int, resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> CallableStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(resultSetType) )
        __args[2] = jvalue( i: jint(resultSetConcurrency) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareCall", methodSig: "(Ljava/lang/String;II)Ljava/sql/CallableStatement;", methodCache: &ConnectionForward.prepareCall_MethodID_83, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? CallableStatementForward( javaObject: __return ) : nil
    }

    open func prepareCall( _ _sql: String?, _ _resultSetType: Int, _ _resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> CallableStatement! {
        return try prepareCall( sql: _sql, resultSetType: _resultSetType, resultSetConcurrency: _resultSetConcurrency )
    }

    /// public abstract java.sql.CallableStatement java.sql.Connection.prepareCall(java.lang.String,int,int,int) throws java.sql.SQLException

    private static var prepareCall_MethodID_84: jmethodID?

    open func prepareCall( sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> CallableStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(resultSetType) )
        __args[2] = jvalue( i: jint(resultSetConcurrency) )
        __args[3] = jvalue( i: jint(resultSetHoldability) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareCall", methodSig: "(Ljava/lang/String;III)Ljava/sql/CallableStatement;", methodCache: &ConnectionForward.prepareCall_MethodID_84, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? CallableStatementForward( javaObject: __return ) : nil
    }

    open func prepareCall( _ _sql: String?, _ _resultSetType: Int, _ _resultSetConcurrency: Int, _ _resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> CallableStatement! {
        return try prepareCall( sql: _sql, resultSetType: _resultSetType, resultSetConcurrency: _resultSetConcurrency, resultSetHoldability: _resultSetHoldability )
    }

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String) throws java.sql.SQLException

    private static var prepareStatement_MethodID_85: jmethodID?

    open func prepareStatement( sql: String? ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareStatement", methodSig: "(Ljava/lang/String;)Ljava/sql/PreparedStatement;", methodCache: &ConnectionForward.prepareStatement_MethodID_85, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? PreparedStatementForward( javaObject: __return ) : nil
    }

    open func prepareStatement( _ _sql: String? ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        return try prepareStatement( sql: _sql )
    }

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int) throws java.sql.SQLException

    private static var prepareStatement_MethodID_86: jmethodID?

    open func prepareStatement( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(autoGeneratedKeys) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareStatement", methodSig: "(Ljava/lang/String;I)Ljava/sql/PreparedStatement;", methodCache: &ConnectionForward.prepareStatement_MethodID_86, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? PreparedStatementForward( javaObject: __return ) : nil
    }

    open func prepareStatement( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        return try prepareStatement( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int) throws java.sql.SQLException

    private static var prepareStatement_MethodID_87: jmethodID?

    open func prepareStatement( sql: String?, resultSetType: Int, resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(resultSetType) )
        __args[2] = jvalue( i: jint(resultSetConcurrency) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareStatement", methodSig: "(Ljava/lang/String;II)Ljava/sql/PreparedStatement;", methodCache: &ConnectionForward.prepareStatement_MethodID_87, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? PreparedStatementForward( javaObject: __return ) : nil
    }

    open func prepareStatement( _ _sql: String?, _ _resultSetType: Int, _ _resultSetConcurrency: Int ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        return try prepareStatement( sql: _sql, resultSetType: _resultSetType, resultSetConcurrency: _resultSetConcurrency )
    }

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int,int,int) throws java.sql.SQLException

    private static var prepareStatement_MethodID_88: jmethodID?

    open func prepareStatement( sql: String?, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(resultSetType) )
        __args[2] = jvalue( i: jint(resultSetConcurrency) )
        __args[3] = jvalue( i: jint(resultSetHoldability) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareStatement", methodSig: "(Ljava/lang/String;III)Ljava/sql/PreparedStatement;", methodCache: &ConnectionForward.prepareStatement_MethodID_88, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? PreparedStatementForward( javaObject: __return ) : nil
    }

    open func prepareStatement( _ _sql: String?, _ _resultSetType: Int, _ _resultSetConcurrency: Int, _ _resultSetHoldability: Int ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        return try prepareStatement( sql: _sql, resultSetType: _resultSetType, resultSetConcurrency: _resultSetConcurrency, resultSetHoldability: _resultSetHoldability )
    }

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,int[]) throws java.sql.SQLException

    private static var prepareStatement_MethodID_89: jmethodID?

    open func prepareStatement( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareStatement", methodSig: "(Ljava/lang/String;[I)Ljava/sql/PreparedStatement;", methodCache: &ConnectionForward.prepareStatement_MethodID_89, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? PreparedStatementForward( javaObject: __return ) : nil
    }

    open func prepareStatement( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        return try prepareStatement( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public abstract java.sql.PreparedStatement java.sql.Connection.prepareStatement(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var prepareStatement_MethodID_90: jmethodID?

    open func prepareStatement( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "prepareStatement", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement;", methodCache: &ConnectionForward.prepareStatement_MethodID_90, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? PreparedStatementForward( javaObject: __return ) : nil
    }

    open func prepareStatement( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> PreparedStatement! {
        return try prepareStatement( sql: _sql, columnNames: _columnNames )
    }

    /// public abstract void java.sql.Connection.releaseSavepoint(java.sql.Savepoint) throws java.sql.SQLException

    private static var releaseSavepoint_MethodID_91: jmethodID?

    open func releaseSavepoint( savepoint: Savepoint? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: savepoint, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "releaseSavepoint", methodSig: "(Ljava/sql/Savepoint;)V", methodCache: &ConnectionForward.releaseSavepoint_MethodID_91, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func releaseSavepoint( _ _savepoint: Savepoint? ) throws /* java.sql.SQLException */ {
        try releaseSavepoint( savepoint: _savepoint )
    }

    /// public abstract void java.sql.Connection.rollback(java.sql.Savepoint) throws java.sql.SQLException

    private static var rollback_MethodID_92: jmethodID?

    open func rollback( savepoint: Savepoint? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: savepoint, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "rollback", methodSig: "(Ljava/sql/Savepoint;)V", methodCache: &ConnectionForward.rollback_MethodID_92, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func rollback( _ _savepoint: Savepoint? ) throws /* java.sql.SQLException */ {
        try rollback( savepoint: _savepoint )
    }

    /// public abstract void java.sql.Connection.rollback() throws java.sql.SQLException

    private static var rollback_MethodID_93: jmethodID?

    open func rollback() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "rollback", methodSig: "()V", methodCache: &ConnectionForward.rollback_MethodID_93, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Connection.setAutoCommit(boolean) throws java.sql.SQLException

    private static var setAutoCommit_MethodID_94: jmethodID?

    open func setAutoCommit( autoCommit: Bool ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(autoCommit ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setAutoCommit", methodSig: "(Z)V", methodCache: &ConnectionForward.setAutoCommit_MethodID_94, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setAutoCommit( _ _autoCommit: Bool ) throws /* java.sql.SQLException */ {
        try setAutoCommit( autoCommit: _autoCommit )
    }

    /// public abstract void java.sql.Connection.setCatalog(java.lang.String) throws java.sql.SQLException

    private static var setCatalog_MethodID_95: jmethodID?

    open func setCatalog( catalog: String? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: catalog, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCatalog", methodSig: "(Ljava/lang/String;)V", methodCache: &ConnectionForward.setCatalog_MethodID_95, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setCatalog( _ _catalog: String? ) throws /* java.sql.SQLException */ {
        try setCatalog( catalog: _catalog )
    }

    /// public abstract void java.sql.Connection.setClientInfo(java.lang.String,java.lang.String) throws java.sql.SQLClientInfoException

    private static var setClientInfo_MethodID_96: jmethodID?

    open func setClientInfo( name: String?, value: String? ) throws /* java.sql.SQLClientInfoException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        __args[1] = JNIType.toJava( value: value, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setClientInfo", methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &ConnectionForward.setClientInfo_MethodID_96, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLClientInfoException( javaObject: throwable )
        }
    }

    open func setClientInfo( _ _name: String?, _ _value: String? ) throws /* java.sql.SQLClientInfoException */ {
        try setClientInfo( name: _name, value: _value )
    }

    /// public abstract void java.sql.Connection.setClientInfo(java.util.Properties) throws java.sql.SQLClientInfoException

    private static var setClientInfo_MethodID_97: jmethodID?

    open func setClientInfo( properties: java_util.Properties? ) throws /* java.sql.SQLClientInfoException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: properties, mapClass: "java/util/Properties", locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setClientInfo", methodSig: "(Ljava/util/Properties;)V", methodCache: &ConnectionForward.setClientInfo_MethodID_97, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLClientInfoException( javaObject: throwable )
        }
    }

    open func setClientInfo( _ _properties: java_util.Properties? ) throws /* java.sql.SQLClientInfoException */ {
        try setClientInfo( properties: _properties )
    }

    /// public abstract void java.sql.Connection.setHoldability(int) throws java.sql.SQLException

    private static var setHoldability_MethodID_98: jmethodID?

    open func setHoldability( holdability: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(holdability) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setHoldability", methodSig: "(I)V", methodCache: &ConnectionForward.setHoldability_MethodID_98, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setHoldability( _ _holdability: Int ) throws /* java.sql.SQLException */ {
        try setHoldability( holdability: _holdability )
    }

    /// public abstract void java.sql.Connection.setNetworkTimeout(java.util.concurrent.Executor,int) throws java.sql.SQLException

    private static var setNetworkTimeout_MethodID_99: jmethodID?

    open func setNetworkTimeout( executor: java_util.Executor?, milliseconds: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: executor, locals: &__locals )
        __args[1] = jvalue( i: jint(milliseconds) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNetworkTimeout", methodSig: "(Ljava/util/concurrent/Executor;I)V", methodCache: &ConnectionForward.setNetworkTimeout_MethodID_99, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setNetworkTimeout( _ _executor: java_util.Executor?, _ _milliseconds: Int ) throws /* java.sql.SQLException */ {
        try setNetworkTimeout( executor: _executor, milliseconds: _milliseconds )
    }

    /// public abstract void java.sql.Connection.setReadOnly(boolean) throws java.sql.SQLException

    private static var setReadOnly_MethodID_100: jmethodID?

    open func setReadOnly( readOnly: Bool ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(readOnly ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setReadOnly", methodSig: "(Z)V", methodCache: &ConnectionForward.setReadOnly_MethodID_100, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setReadOnly( _ _readOnly: Bool ) throws /* java.sql.SQLException */ {
        try setReadOnly( readOnly: _readOnly )
    }

    /// public abstract java.sql.Savepoint java.sql.Connection.setSavepoint(java.lang.String) throws java.sql.SQLException

    private static var setSavepoint_MethodID_101: jmethodID?

    open func setSavepoint( name: String? ) throws /* java.sql.SQLException */ -> Savepoint! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "setSavepoint", methodSig: "(Ljava/lang/String;)Ljava/sql/Savepoint;", methodCache: &ConnectionForward.setSavepoint_MethodID_101, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SavepointForward( javaObject: __return ) : nil
    }

    open func setSavepoint( _ _name: String? ) throws /* java.sql.SQLException */ -> Savepoint! {
        return try setSavepoint( name: _name )
    }

    /// public abstract java.sql.Savepoint java.sql.Connection.setSavepoint() throws java.sql.SQLException

    private static var setSavepoint_MethodID_102: jmethodID?

    open func setSavepoint() throws /* java.sql.SQLException */ -> Savepoint! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "setSavepoint", methodSig: "()Ljava/sql/Savepoint;", methodCache: &ConnectionForward.setSavepoint_MethodID_102, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SavepointForward( javaObject: __return ) : nil
    }


    /// public abstract void java.sql.Connection.setSchema(java.lang.String) throws java.sql.SQLException

    private static var setSchema_MethodID_103: jmethodID?

    open func setSchema( schema: String? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: schema, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setSchema", methodSig: "(Ljava/lang/String;)V", methodCache: &ConnectionForward.setSchema_MethodID_103, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setSchema( _ _schema: String? ) throws /* java.sql.SQLException */ {
        try setSchema( schema: _schema )
    }

    /// public abstract void java.sql.Connection.setTransactionIsolation(int) throws java.sql.SQLException

    private static var setTransactionIsolation_MethodID_104: jmethodID?

    open func setTransactionIsolation( level: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(level) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTransactionIsolation", methodSig: "(I)V", methodCache: &ConnectionForward.setTransactionIsolation_MethodID_104, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setTransactionIsolation( _ _level: Int ) throws /* java.sql.SQLException */ {
        try setTransactionIsolation( level: _level )
    }

    /// public abstract void java.sql.Connection.setTypeMap(java.util.Map) throws java.sql.SQLException

    private static var setTypeMap_MethodID_105: jmethodID?

    open func setTypeMap( map: java_swift.JavaMap? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: map, mapClass: "java/util/Map", locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setTypeMap", methodSig: "(Ljava/util/Map;)V", methodCache: &ConnectionForward.setTypeMap_MethodID_105, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setTypeMap( _ _map: java_swift.JavaMap? ) throws /* java.sql.SQLException */ {
        try setTypeMap( map: _map )
    }

    /// public abstract java.lang.Object java.sql.Wrapper.unwrap(java.lang.Class) throws java.sql.SQLException

    private static var unwrap_MethodID_106: jmethodID?

    override open func unwrap( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: iface, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unwrap", methodSig: "(Ljava/lang/Class;)Ljava/lang/Object;", methodCache: &ConnectionForward.unwrap_MethodID_106, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    override open func unwrap( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        return try unwrap( iface: _iface )
    }

}

