
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.sql.ResultSetMetaData ///

public protocol ResultSetMetaData: Wrapper {

    /// public static final int java.sql.ResultSetMetaData.columnNoNulls

    // Skipping field: false false false false false true 

    /// public static final int java.sql.ResultSetMetaData.columnNullable

    // Skipping field: false false false false false true 

    /// public static final int java.sql.ResultSetMetaData.columnNullableUnknown

    // Skipping field: false false false false false true 

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getCatalogName(int) throws java.sql.SQLException

    func getCatalogName( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnClassName(int) throws java.sql.SQLException

    func getColumnClassName( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract int java.sql.ResultSetMetaData.getColumnCount() throws java.sql.SQLException

    func getColumnCount() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.ResultSetMetaData.getColumnDisplaySize(int) throws java.sql.SQLException

    func getColumnDisplaySize( column: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnLabel(int) throws java.sql.SQLException

    func getColumnLabel( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnName(int) throws java.sql.SQLException

    func getColumnName( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract int java.sql.ResultSetMetaData.getColumnType(int) throws java.sql.SQLException

    func getColumnType( column: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnTypeName(int) throws java.sql.SQLException

    func getColumnTypeName( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract int java.sql.ResultSetMetaData.getPrecision(int) throws java.sql.SQLException

    func getPrecision( column: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.ResultSetMetaData.getScale(int) throws java.sql.SQLException

    func getScale( column: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getSchemaName(int) throws java.sql.SQLException

    func getSchemaName( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getTableName(int) throws java.sql.SQLException

    func getTableName( column: Int ) throws /* java.sql.SQLException */ -> String!

    /// public abstract boolean java.sql.ResultSetMetaData.isAutoIncrement(int) throws java.sql.SQLException

    func isAutoIncrement( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.ResultSetMetaData.isCaseSensitive(int) throws java.sql.SQLException

    func isCaseSensitive( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.ResultSetMetaData.isCurrency(int) throws java.sql.SQLException

    func isCurrency( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.ResultSetMetaData.isDefinitelyWritable(int) throws java.sql.SQLException

    func isDefinitelyWritable( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract int java.sql.ResultSetMetaData.isNullable(int) throws java.sql.SQLException

    func isNullable( column: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract boolean java.sql.ResultSetMetaData.isReadOnly(int) throws java.sql.SQLException

    func isReadOnly( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.ResultSetMetaData.isSearchable(int) throws java.sql.SQLException

    func isSearchable( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.ResultSetMetaData.isSigned(int) throws java.sql.SQLException

    func isSigned( column: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.ResultSetMetaData.isWritable(int) throws java.sql.SQLException

    func isWritable( column: Int ) throws /* java.sql.SQLException */ -> Bool

}


open class ResultSetMetaDataForward: WrapperForward, ResultSetMetaData {

    private static var ResultSetMetaDataJNIClass: jclass?

    /// public static final int java.sql.ResultSetMetaData.columnNoNulls

    private static var columnNoNulls_FieldID: jfieldID?

    public static var columnNoNulls: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "columnNoNulls", fieldType: "I", fieldCache: &columnNoNulls_FieldID, className: "java/sql/ResultSetMetaData", classCache: &ResultSetMetaDataJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.ResultSetMetaData.columnNullable

    private static var columnNullable_FieldID: jfieldID?

    public static var columnNullable: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "columnNullable", fieldType: "I", fieldCache: &columnNullable_FieldID, className: "java/sql/ResultSetMetaData", classCache: &ResultSetMetaDataJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.ResultSetMetaData.columnNullableUnknown

    private static var columnNullableUnknown_FieldID: jfieldID?

    public static var columnNullableUnknown: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "columnNullableUnknown", fieldType: "I", fieldCache: &columnNullableUnknown_FieldID, className: "java/sql/ResultSetMetaData", classCache: &ResultSetMetaDataJNIClass )
            return Int(__value)
        }
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getCatalogName(int) throws java.sql.SQLException

    private static var getCatalogName_MethodID_22: jmethodID?

    open func getCatalogName( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getCatalogName", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getCatalogName_MethodID_22, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getCatalogName( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getCatalogName( column: _column )
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnClassName(int) throws java.sql.SQLException

    private static var getColumnClassName_MethodID_23: jmethodID?

    open func getColumnClassName( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getColumnClassName", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getColumnClassName_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getColumnClassName( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getColumnClassName( column: _column )
    }

    /// public abstract int java.sql.ResultSetMetaData.getColumnCount() throws java.sql.SQLException

    private static var getColumnCount_MethodID_24: jmethodID?

    open func getColumnCount() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getColumnCount", methodSig: "()I", methodCache: &ResultSetMetaDataForward.getColumnCount_MethodID_24, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract int java.sql.ResultSetMetaData.getColumnDisplaySize(int) throws java.sql.SQLException

    private static var getColumnDisplaySize_MethodID_25: jmethodID?

    open func getColumnDisplaySize( column: Int ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getColumnDisplaySize", methodSig: "(I)I", methodCache: &ResultSetMetaDataForward.getColumnDisplaySize_MethodID_25, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func getColumnDisplaySize( _ _column: Int ) throws /* java.sql.SQLException */ -> Int {
        return try getColumnDisplaySize( column: _column )
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnLabel(int) throws java.sql.SQLException

    private static var getColumnLabel_MethodID_26: jmethodID?

    open func getColumnLabel( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getColumnLabel", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getColumnLabel_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getColumnLabel( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getColumnLabel( column: _column )
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnName(int) throws java.sql.SQLException

    private static var getColumnName_MethodID_27: jmethodID?

    open func getColumnName( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getColumnName", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getColumnName_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getColumnName( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getColumnName( column: _column )
    }

    /// public abstract int java.sql.ResultSetMetaData.getColumnType(int) throws java.sql.SQLException

    private static var getColumnType_MethodID_28: jmethodID?

    open func getColumnType( column: Int ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getColumnType", methodSig: "(I)I", methodCache: &ResultSetMetaDataForward.getColumnType_MethodID_28, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func getColumnType( _ _column: Int ) throws /* java.sql.SQLException */ -> Int {
        return try getColumnType( column: _column )
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getColumnTypeName(int) throws java.sql.SQLException

    private static var getColumnTypeName_MethodID_29: jmethodID?

    open func getColumnTypeName( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getColumnTypeName", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getColumnTypeName_MethodID_29, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getColumnTypeName( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getColumnTypeName( column: _column )
    }

    /// public abstract int java.sql.ResultSetMetaData.getPrecision(int) throws java.sql.SQLException

    private static var getPrecision_MethodID_30: jmethodID?

    open func getPrecision( column: Int ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getPrecision", methodSig: "(I)I", methodCache: &ResultSetMetaDataForward.getPrecision_MethodID_30, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func getPrecision( _ _column: Int ) throws /* java.sql.SQLException */ -> Int {
        return try getPrecision( column: _column )
    }

    /// public abstract int java.sql.ResultSetMetaData.getScale(int) throws java.sql.SQLException

    private static var getScale_MethodID_31: jmethodID?

    open func getScale( column: Int ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getScale", methodSig: "(I)I", methodCache: &ResultSetMetaDataForward.getScale_MethodID_31, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func getScale( _ _column: Int ) throws /* java.sql.SQLException */ -> Int {
        return try getScale( column: _column )
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getSchemaName(int) throws java.sql.SQLException

    private static var getSchemaName_MethodID_32: jmethodID?

    open func getSchemaName( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSchemaName", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getSchemaName_MethodID_32, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getSchemaName( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getSchemaName( column: _column )
    }

    /// public abstract java.lang.String java.sql.ResultSetMetaData.getTableName(int) throws java.sql.SQLException

    private static var getTableName_MethodID_33: jmethodID?

    open func getTableName( column: Int ) throws /* java.sql.SQLException */ -> String! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTableName", methodSig: "(I)Ljava/lang/String;", methodCache: &ResultSetMetaDataForward.getTableName_MethodID_33, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? String( javaObject: __return ) : nil
    }

    open func getTableName( _ _column: Int ) throws /* java.sql.SQLException */ -> String! {
        return try getTableName( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isAutoIncrement(int) throws java.sql.SQLException

    private static var isAutoIncrement_MethodID_34: jmethodID?

    open func isAutoIncrement( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAutoIncrement", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isAutoIncrement_MethodID_34, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isAutoIncrement( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isAutoIncrement( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isCaseSensitive(int) throws java.sql.SQLException

    private static var isCaseSensitive_MethodID_35: jmethodID?

    open func isCaseSensitive( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCaseSensitive", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isCaseSensitive_MethodID_35, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isCaseSensitive( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isCaseSensitive( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isCurrency(int) throws java.sql.SQLException

    private static var isCurrency_MethodID_36: jmethodID?

    open func isCurrency( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCurrency", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isCurrency_MethodID_36, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isCurrency( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isCurrency( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isDefinitelyWritable(int) throws java.sql.SQLException

    private static var isDefinitelyWritable_MethodID_37: jmethodID?

    open func isDefinitelyWritable( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isDefinitelyWritable", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isDefinitelyWritable_MethodID_37, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isDefinitelyWritable( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isDefinitelyWritable( column: _column )
    }

    /// public abstract int java.sql.ResultSetMetaData.isNullable(int) throws java.sql.SQLException

    private static var isNullable_MethodID_38: jmethodID?

    open func isNullable( column: Int ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "isNullable", methodSig: "(I)I", methodCache: &ResultSetMetaDataForward.isNullable_MethodID_38, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func isNullable( _ _column: Int ) throws /* java.sql.SQLException */ -> Int {
        return try isNullable( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isReadOnly(int) throws java.sql.SQLException

    private static var isReadOnly_MethodID_39: jmethodID?

    open func isReadOnly( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isReadOnly", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isReadOnly_MethodID_39, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isReadOnly( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isReadOnly( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isSearchable(int) throws java.sql.SQLException

    private static var isSearchable_MethodID_40: jmethodID?

    open func isSearchable( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSearchable", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isSearchable_MethodID_40, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isSearchable( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isSearchable( column: _column )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isSigned(int) throws java.sql.SQLException

    private static var isSigned_MethodID_41: jmethodID?

    open func isSigned( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSigned", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isSigned_MethodID_41, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isSigned( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isSigned( column: _column )
    }

    /// public abstract boolean java.sql.Wrapper.isWrapperFor(java.lang.Class) throws java.sql.SQLException

    private static var isWrapperFor_MethodID_42: jmethodID?

    override open func isWrapperFor( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: iface, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isWrapperFor", methodSig: "(Ljava/lang/Class;)Z", methodCache: &ResultSetMetaDataForward.isWrapperFor_MethodID_42, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    override open func isWrapperFor( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        return try isWrapperFor( iface: _iface )
    }

    /// public abstract boolean java.sql.ResultSetMetaData.isWritable(int) throws java.sql.SQLException

    private static var isWritable_MethodID_43: jmethodID?

    open func isWritable( column: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(column) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isWritable", methodSig: "(I)Z", methodCache: &ResultSetMetaDataForward.isWritable_MethodID_43, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func isWritable( _ _column: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try isWritable( column: _column )
    }

    /// public abstract java.lang.Object java.sql.Wrapper.unwrap(java.lang.Class) throws java.sql.SQLException

    private static var unwrap_MethodID_44: jmethodID?

    override open func unwrap( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: iface, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unwrap", methodSig: "(Ljava/lang/Class;)Ljava/lang/Object;", methodCache: &ResultSetMetaDataForward.unwrap_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    override open func unwrap( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        return try unwrap( iface: _iface )
    }

}

