
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:34 GMT 2016 ///

/// interface java.sql.Statement ///

public protocol Statement: Wrapper {

    /// public static final int java.sql.Statement.CLOSE_CURRENT_RESULT

    static var CLOSE_CURRENT_RESULT: Int { get }

    /// public static final int java.sql.Statement.KEEP_CURRENT_RESULT

    static var KEEP_CURRENT_RESULT: Int { get }

    /// public static final int java.sql.Statement.CLOSE_ALL_RESULTS

    static var CLOSE_ALL_RESULTS: Int { get }

    /// public static final int java.sql.Statement.SUCCESS_NO_INFO

    static var SUCCESS_NO_INFO: Int { get }

    /// public static final int java.sql.Statement.EXECUTE_FAILED

    static var EXECUTE_FAILED: Int { get }

    /// public static final int java.sql.Statement.RETURN_GENERATED_KEYS

    static var RETURN_GENERATED_KEYS: Int { get }

    /// public static final int java.sql.Statement.NO_GENERATED_KEYS

    static var NO_GENERATED_KEYS: Int { get }

    /// public abstract void java.sql.Statement.close() throws java.sql.SQLException

    func close() throws /* java.sql.SQLException */

    /// public abstract boolean java.sql.Statement.isClosed() throws java.sql.SQLException

    func isClosed() throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String) throws java.sql.SQLException

    func execute( arg0: String? ) throws /* java.sql.SQLException */ -> Bool
    func execute( _ _arg0: String? ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    func execute( arg0: String?, arg1: [String]? ) throws /* java.sql.SQLException */ -> Bool
    func execute( _ _arg0: String?, _ _arg1: [String]? ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int[]) throws java.sql.SQLException

    func execute( arg0: String?, arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Bool
    func execute( _ _arg0: String?, _ _arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int) throws java.sql.SQLException

    func execute( arg0: String?, arg1: Int ) throws /* java.sql.SQLException */ -> Bool
    func execute( _ _arg0: String?, _ _arg1: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract java.sql.ResultSet java.sql.Statement.getResultSet() throws java.sql.SQLException

    func getResultSet() throws /* java.sql.SQLException */ -> ResultSet!

    /// public abstract java.sql.SQLWarning java.sql.Statement.getWarnings() throws java.sql.SQLException

    func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning!

    /// public abstract void java.sql.Statement.clearWarnings() throws java.sql.SQLException

    func clearWarnings() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setFetchDirection(int) throws java.sql.SQLException

    func setFetchDirection( arg0: Int ) throws /* java.sql.SQLException */
    func setFetchDirection( _ _arg0: Int ) throws /* java.sql.SQLException */

    /// public abstract int java.sql.Statement.getFetchDirection() throws java.sql.SQLException

    func getFetchDirection() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.setFetchSize(int) throws java.sql.SQLException

    func setFetchSize( arg0: Int ) throws /* java.sql.SQLException */
    func setFetchSize( _ _arg0: Int ) throws /* java.sql.SQLException */

    /// public abstract int java.sql.Statement.getFetchSize() throws java.sql.SQLException

    func getFetchSize() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.sql.ResultSet java.sql.Statement.executeQuery(java.lang.String) throws java.sql.SQLException

    func executeQuery( arg0: String? ) throws /* java.sql.SQLException */ -> ResultSet!
    func executeQuery( _ _arg0: String? ) throws /* java.sql.SQLException */ -> ResultSet!

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    func executeUpdate( arg0: String?, arg1: [String]? ) throws /* java.sql.SQLException */ -> Int
    func executeUpdate( _ _arg0: String?, _ _arg1: [String]? ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    func executeUpdate( arg0: String?, arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Int
    func executeUpdate( _ _arg0: String?, _ _arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int) throws java.sql.SQLException

    func executeUpdate( arg0: String?, arg1: Int ) throws /* java.sql.SQLException */ -> Int
    func executeUpdate( _ _arg0: String?, _ _arg1: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String) throws java.sql.SQLException

    func executeUpdate( arg0: String? ) throws /* java.sql.SQLException */ -> Int
    func executeUpdate( _ _arg0: String? ) throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.addBatch(java.lang.String) throws java.sql.SQLException

    func addBatch( arg0: String? ) throws /* java.sql.SQLException */
    func addBatch( _ _arg0: String? ) throws /* java.sql.SQLException */

    /// public abstract int java.sql.Statement.getMaxFieldSize() throws java.sql.SQLException

    func getMaxFieldSize() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.setMaxFieldSize(int) throws java.sql.SQLException

    func setMaxFieldSize( arg0: Int ) throws /* java.sql.SQLException */
    func setMaxFieldSize( _ _arg0: Int ) throws /* java.sql.SQLException */

    /// public abstract int java.sql.Statement.getMaxRows() throws java.sql.SQLException

    func getMaxRows() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.setMaxRows(int) throws java.sql.SQLException

    func setMaxRows( arg0: Int ) throws /* java.sql.SQLException */
    func setMaxRows( _ _arg0: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setEscapeProcessing(boolean) throws java.sql.SQLException

    func setEscapeProcessing( arg0: Bool ) throws /* java.sql.SQLException */
    func setEscapeProcessing( _ _arg0: Bool ) throws /* java.sql.SQLException */

    /// public abstract int java.sql.Statement.getQueryTimeout() throws java.sql.SQLException

    func getQueryTimeout() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.setQueryTimeout(int) throws java.sql.SQLException

    func setQueryTimeout( arg0: Int ) throws /* java.sql.SQLException */
    func setQueryTimeout( _ _arg0: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.cancel() throws java.sql.SQLException

    func cancel() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setCursorName(java.lang.String) throws java.sql.SQLException

    func setCursorName( arg0: String? ) throws /* java.sql.SQLException */
    func setCursorName( _ _arg0: String? ) throws /* java.sql.SQLException */

    /// public abstract int java.sql.Statement.getUpdateCount() throws java.sql.SQLException

    func getUpdateCount() throws /* java.sql.SQLException */ -> Int

    /// public abstract boolean java.sql.Statement.getMoreResults(int) throws java.sql.SQLException

    func getMoreResults( arg0: Int ) throws /* java.sql.SQLException */ -> Bool
    func getMoreResults( _ _arg0: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.getMoreResults() throws java.sql.SQLException

    func getMoreResults() throws /* java.sql.SQLException */ -> Bool

    /// public abstract int java.sql.Statement.getResultSetConcurrency() throws java.sql.SQLException

    func getResultSetConcurrency() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.getResultSetType() throws java.sql.SQLException

    func getResultSetType() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.clearBatch() throws java.sql.SQLException

    func clearBatch() throws /* java.sql.SQLException */

    /// public abstract int[] java.sql.Statement.executeBatch() throws java.sql.SQLException

    func executeBatch() throws /* java.sql.SQLException */ -> [Int32]!

    /// public abstract java.sql.Connection java.sql.Statement.getConnection() throws java.sql.SQLException

    func getConnection() throws /* java.sql.SQLException */ -> Connection!

    /// public abstract java.sql.ResultSet java.sql.Statement.getGeneratedKeys() throws java.sql.SQLException

    func getGeneratedKeys() throws /* java.sql.SQLException */ -> ResultSet!

    /// public abstract int java.sql.Statement.getResultSetHoldability() throws java.sql.SQLException

    func getResultSetHoldability() throws /* java.sql.SQLException */ -> Int

    /// public abstract void java.sql.Statement.setPoolable(boolean) throws java.sql.SQLException

    func setPoolable( arg0: Bool ) throws /* java.sql.SQLException */
    func setPoolable( _ _arg0: Bool ) throws /* java.sql.SQLException */

    /// public abstract boolean java.sql.Statement.isPoolable() throws java.sql.SQLException

    func isPoolable() throws /* java.sql.SQLException */ -> Bool

}

open class StatementForward: WrapperForward, Statement {

    private static var StatementJNIClass: jclass?

    /// public static final int java.sql.Statement.CLOSE_CURRENT_RESULT

    private static var CLOSE_CURRENT_RESULT_FieldID: jfieldID?

    open static var CLOSE_CURRENT_RESULT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CLOSE_CURRENT_RESULT", fieldType: "I", fieldCache: &CLOSE_CURRENT_RESULT_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.sql.Statement.KEEP_CURRENT_RESULT

    private static var KEEP_CURRENT_RESULT_FieldID: jfieldID?

    open static var KEEP_CURRENT_RESULT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "KEEP_CURRENT_RESULT", fieldType: "I", fieldCache: &KEEP_CURRENT_RESULT_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.sql.Statement.CLOSE_ALL_RESULTS

    private static var CLOSE_ALL_RESULTS_FieldID: jfieldID?

    open static var CLOSE_ALL_RESULTS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CLOSE_ALL_RESULTS", fieldType: "I", fieldCache: &CLOSE_ALL_RESULTS_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.sql.Statement.SUCCESS_NO_INFO

    private static var SUCCESS_NO_INFO_FieldID: jfieldID?

    open static var SUCCESS_NO_INFO: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "SUCCESS_NO_INFO", fieldType: "I", fieldCache: &SUCCESS_NO_INFO_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.sql.Statement.EXECUTE_FAILED

    private static var EXECUTE_FAILED_FieldID: jfieldID?

    open static var EXECUTE_FAILED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "EXECUTE_FAILED", fieldType: "I", fieldCache: &EXECUTE_FAILED_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.sql.Statement.RETURN_GENERATED_KEYS

    private static var RETURN_GENERATED_KEYS_FieldID: jfieldID?

    open static var RETURN_GENERATED_KEYS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "RETURN_GENERATED_KEYS", fieldType: "I", fieldCache: &RETURN_GENERATED_KEYS_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.sql.Statement.NO_GENERATED_KEYS

    private static var NO_GENERATED_KEYS_FieldID: jfieldID?

    open static var NO_GENERATED_KEYS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "NO_GENERATED_KEYS", fieldType: "I", fieldCache: &NO_GENERATED_KEYS_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public abstract void java.sql.Statement.close() throws java.sql.SQLException

    private static var close_MethodID_41: jmethodID?

    open func close() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &StatementForward.close_MethodID_41, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract boolean java.sql.Statement.isClosed() throws java.sql.SQLException

    private static var isClosed_MethodID_42: jmethodID?

    open func isClosed() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isClosed", methodSig: "()Z", methodCache: &StatementForward.isClosed_MethodID_42, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public abstract boolean java.sql.Statement.execute(java.lang.String) throws java.sql.SQLException

    private static var execute_MethodID_43: jmethodID?

    open func execute( arg0: String? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;)Z", methodCache: &StatementForward.execute_MethodID_43, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func execute( _ _arg0: String? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( arg0: _arg0 )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var execute_MethodID_44: jmethodID?

    open func execute( arg0: String?, arg1: [String]? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)Z", methodCache: &StatementForward.execute_MethodID_44, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func execute( _ _arg0: String?, _ _arg1: [String]? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int[]) throws java.sql.SQLException

    private static var execute_MethodID_45: jmethodID?

    open func execute( arg0: String?, arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;[I)Z", methodCache: &StatementForward.execute_MethodID_45, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func execute( _ _arg0: String?, _ _arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int) throws java.sql.SQLException

    private static var execute_MethodID_46: jmethodID?

    open func execute( arg0: String?, arg1: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;I)Z", methodCache: &StatementForward.execute_MethodID_46, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func execute( _ _arg0: String?, _ _arg1: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract java.sql.ResultSet java.sql.Statement.getResultSet() throws java.sql.SQLException

    private static var getResultSet_MethodID_47: jmethodID?

    open func getResultSet() throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResultSet", methodSig: "()Ljava/sql/ResultSet;", methodCache: &StatementForward.getResultSet_MethodID_47, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.SQLWarning java.sql.Statement.getWarnings() throws java.sql.SQLException

    private static var getWarnings_MethodID_48: jmethodID?

    open func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getWarnings", methodSig: "()Ljava/sql/SQLWarning;", methodCache: &StatementForward.getWarnings_MethodID_48, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SQLWarning( javaObject: __return ) : nil
    }


    /// public abstract void java.sql.Statement.clearWarnings() throws java.sql.SQLException

    private static var clearWarnings_MethodID_49: jmethodID?

    open func clearWarnings() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearWarnings", methodSig: "()V", methodCache: &StatementForward.clearWarnings_MethodID_49, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.setFetchDirection(int) throws java.sql.SQLException

    private static var setFetchDirection_MethodID_50: jmethodID?

    open func setFetchDirection( arg0: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFetchDirection", methodSig: "(I)V", methodCache: &StatementForward.setFetchDirection_MethodID_50, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setFetchDirection( _ _arg0: Int ) throws /* java.sql.SQLException */ {
        try setFetchDirection( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.getFetchDirection() throws java.sql.SQLException

    private static var getFetchDirection_MethodID_51: jmethodID?

    open func getFetchDirection() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getFetchDirection", methodSig: "()I", methodCache: &StatementForward.getFetchDirection_MethodID_51, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setFetchSize(int) throws java.sql.SQLException

    private static var setFetchSize_MethodID_52: jmethodID?

    open func setFetchSize( arg0: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFetchSize", methodSig: "(I)V", methodCache: &StatementForward.setFetchSize_MethodID_52, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setFetchSize( _ _arg0: Int ) throws /* java.sql.SQLException */ {
        try setFetchSize( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.getFetchSize() throws java.sql.SQLException

    private static var getFetchSize_MethodID_53: jmethodID?

    open func getFetchSize() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getFetchSize", methodSig: "()I", methodCache: &StatementForward.getFetchSize_MethodID_53, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.executeQuery(java.lang.String) throws java.sql.SQLException

    private static var executeQuery_MethodID_54: jmethodID?

    open func executeQuery( arg0: String? ) throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeQuery", methodSig: "(Ljava/lang/String;)Ljava/sql/ResultSet;", methodCache: &StatementForward.executeQuery_MethodID_54, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }

    open func executeQuery( _ _arg0: String? ) throws /* java.sql.SQLException */ -> ResultSet! {
        return try executeQuery( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var executeUpdate_MethodID_55: jmethodID?

    open func executeUpdate( arg0: String?, arg1: [String]? ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)I", methodCache: &StatementForward.executeUpdate_MethodID_55, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }

    open func executeUpdate( _ _arg0: String?, _ _arg1: [String]? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    private static var executeUpdate_MethodID_56: jmethodID?

    open func executeUpdate( arg0: String?, arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;[I)I", methodCache: &StatementForward.executeUpdate_MethodID_56, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }

    open func executeUpdate( _ _arg0: String?, _ _arg1: [Int32]? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int) throws java.sql.SQLException

    private static var executeUpdate_MethodID_57: jmethodID?

    open func executeUpdate( arg0: String?, arg1: Int ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;I)I", methodCache: &StatementForward.executeUpdate_MethodID_57, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }

    open func executeUpdate( _ _arg0: String?, _ _arg1: Int ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String) throws java.sql.SQLException

    private static var executeUpdate_MethodID_58: jmethodID?

    open func executeUpdate( arg0: String? ) throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;)I", methodCache: &StatementForward.executeUpdate_MethodID_58, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }

    open func executeUpdate( _ _arg0: String? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( arg0: _arg0 )
    }

    /// public abstract void java.sql.Statement.addBatch(java.lang.String) throws java.sql.SQLException

    private static var addBatch_MethodID_59: jmethodID?

    open func addBatch( arg0: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addBatch", methodSig: "(Ljava/lang/String;)V", methodCache: &StatementForward.addBatch_MethodID_59, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func addBatch( _ _arg0: String? ) throws /* java.sql.SQLException */ {
        try addBatch( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.getMaxFieldSize() throws java.sql.SQLException

    private static var getMaxFieldSize_MethodID_60: jmethodID?

    open func getMaxFieldSize() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMaxFieldSize", methodSig: "()I", methodCache: &StatementForward.getMaxFieldSize_MethodID_60, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setMaxFieldSize(int) throws java.sql.SQLException

    private static var setMaxFieldSize_MethodID_61: jmethodID?

    open func setMaxFieldSize( arg0: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setMaxFieldSize", methodSig: "(I)V", methodCache: &StatementForward.setMaxFieldSize_MethodID_61, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setMaxFieldSize( _ _arg0: Int ) throws /* java.sql.SQLException */ {
        try setMaxFieldSize( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.getMaxRows() throws java.sql.SQLException

    private static var getMaxRows_MethodID_62: jmethodID?

    open func getMaxRows() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMaxRows", methodSig: "()I", methodCache: &StatementForward.getMaxRows_MethodID_62, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setMaxRows(int) throws java.sql.SQLException

    private static var setMaxRows_MethodID_63: jmethodID?

    open func setMaxRows( arg0: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setMaxRows", methodSig: "(I)V", methodCache: &StatementForward.setMaxRows_MethodID_63, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setMaxRows( _ _arg0: Int ) throws /* java.sql.SQLException */ {
        try setMaxRows( arg0: _arg0 )
    }

    /// public abstract void java.sql.Statement.setEscapeProcessing(boolean) throws java.sql.SQLException

    private static var setEscapeProcessing_MethodID_64: jmethodID?

    open func setEscapeProcessing( arg0: Bool ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setEscapeProcessing", methodSig: "(Z)V", methodCache: &StatementForward.setEscapeProcessing_MethodID_64, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setEscapeProcessing( _ _arg0: Bool ) throws /* java.sql.SQLException */ {
        try setEscapeProcessing( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.getQueryTimeout() throws java.sql.SQLException

    private static var getQueryTimeout_MethodID_65: jmethodID?

    open func getQueryTimeout() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getQueryTimeout", methodSig: "()I", methodCache: &StatementForward.getQueryTimeout_MethodID_65, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setQueryTimeout(int) throws java.sql.SQLException

    private static var setQueryTimeout_MethodID_66: jmethodID?

    open func setQueryTimeout( arg0: Int ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setQueryTimeout", methodSig: "(I)V", methodCache: &StatementForward.setQueryTimeout_MethodID_66, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setQueryTimeout( _ _arg0: Int ) throws /* java.sql.SQLException */ {
        try setQueryTimeout( arg0: _arg0 )
    }

    /// public abstract void java.sql.Statement.cancel() throws java.sql.SQLException

    private static var cancel_MethodID_67: jmethodID?

    open func cancel() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "cancel", methodSig: "()V", methodCache: &StatementForward.cancel_MethodID_67, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.setCursorName(java.lang.String) throws java.sql.SQLException

    private static var setCursorName_MethodID_68: jmethodID?

    open func setCursorName( arg0: String? ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCursorName", methodSig: "(Ljava/lang/String;)V", methodCache: &StatementForward.setCursorName_MethodID_68, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setCursorName( _ _arg0: String? ) throws /* java.sql.SQLException */ {
        try setCursorName( arg0: _arg0 )
    }

    /// public abstract int java.sql.Statement.getUpdateCount() throws java.sql.SQLException

    private static var getUpdateCount_MethodID_69: jmethodID?

    open func getUpdateCount() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getUpdateCount", methodSig: "()I", methodCache: &StatementForward.getUpdateCount_MethodID_69, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract boolean java.sql.Statement.getMoreResults(int) throws java.sql.SQLException

    private static var getMoreResults_MethodID_70: jmethodID?

    open func getMoreResults( arg0: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getMoreResults", methodSig: "(I)Z", methodCache: &StatementForward.getMoreResults_MethodID_70, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func getMoreResults( _ _arg0: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try getMoreResults( arg0: _arg0 )
    }

    /// public abstract boolean java.sql.Statement.getMoreResults() throws java.sql.SQLException

    private static var getMoreResults_MethodID_71: jmethodID?

    open func getMoreResults() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getMoreResults", methodSig: "()Z", methodCache: &StatementForward.getMoreResults_MethodID_71, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public abstract int java.sql.Statement.getResultSetConcurrency() throws java.sql.SQLException

    private static var getResultSetConcurrency_MethodID_72: jmethodID?

    open func getResultSetConcurrency() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetConcurrency", methodSig: "()I", methodCache: &StatementForward.getResultSetConcurrency_MethodID_72, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract int java.sql.Statement.getResultSetType() throws java.sql.SQLException

    private static var getResultSetType_MethodID_73: jmethodID?

    open func getResultSetType() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetType", methodSig: "()I", methodCache: &StatementForward.getResultSetType_MethodID_73, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.clearBatch() throws java.sql.SQLException

    private static var clearBatch_MethodID_74: jmethodID?

    open func clearBatch() throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearBatch", methodSig: "()V", methodCache: &StatementForward.clearBatch_MethodID_74, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract int[] java.sql.Statement.executeBatch() throws java.sql.SQLException

    private static var executeBatch_MethodID_75: jmethodID?

    open func executeBatch() throws /* java.sql.SQLException */ -> [Int32]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeBatch", methodSig: "()[I", methodCache: &StatementForward.executeBatch_MethodID_75, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: [Int32](), from: __return )
    }


    /// public abstract java.sql.Connection java.sql.Statement.getConnection() throws java.sql.SQLException

    private static var getConnection_MethodID_76: jmethodID?

    open func getConnection() throws /* java.sql.SQLException */ -> Connection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConnection", methodSig: "()Ljava/sql/Connection;", methodCache: &StatementForward.getConnection_MethodID_76, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ConnectionForward( javaObject: __return ) : nil
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.getGeneratedKeys() throws java.sql.SQLException

    private static var getGeneratedKeys_MethodID_77: jmethodID?

    open func getGeneratedKeys() throws /* java.sql.SQLException */ -> ResultSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGeneratedKeys", methodSig: "()Ljava/sql/ResultSet;", methodCache: &StatementForward.getGeneratedKeys_MethodID_77, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.Statement.getResultSetHoldability() throws java.sql.SQLException

    private static var getResultSetHoldability_MethodID_78: jmethodID?

    open func getResultSetHoldability() throws /* java.sql.SQLException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetHoldability", methodSig: "()I", methodCache: &StatementForward.getResultSetHoldability_MethodID_78, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract void java.sql.Statement.setPoolable(boolean) throws java.sql.SQLException

    private static var setPoolable_MethodID_79: jmethodID?

    open func setPoolable( arg0: Bool ) throws /* java.sql.SQLException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setPoolable", methodSig: "(Z)V", methodCache: &StatementForward.setPoolable_MethodID_79, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
    }

    open func setPoolable( _ _arg0: Bool ) throws /* java.sql.SQLException */ {
        try setPoolable( arg0: _arg0 )
    }

    /// public abstract boolean java.sql.Statement.isPoolable() throws java.sql.SQLException

    private static var isPoolable_MethodID_80: jmethodID?

    open func isPoolable() throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isPoolable", methodSig: "()Z", methodCache: &StatementForward.isPoolable_MethodID_80, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public abstract java.lang.Object java.sql.Wrapper.unwrap(java.lang.Class) throws java.sql.SQLException

    private static var unwrap_MethodID_81: jmethodID?

    override open func unwrap( arg0: java_lang.Class? ) throws /* java.sql.SQLException */ -> java_lang.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unwrap", methodSig: "(Ljava/lang/Class;)Ljava/lang/Object;", methodCache: &StatementForward.unwrap_MethodID_81, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? java_lang.JavaObject( javaObject: __return ) : nil
    }

    override open func unwrap( _ _arg0: java_lang.Class? ) throws /* java.sql.SQLException */ -> java_lang.JavaObject! {
        return try unwrap( arg0: _arg0 )
    }

    /// public abstract boolean java.sql.Wrapper.isWrapperFor(java.lang.Class) throws java.sql.SQLException

    private static var isWrapperFor_MethodID_82: jmethodID?

    override open func isWrapperFor( arg0: java_lang.Class? ) throws /* java.sql.SQLException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isWrapperFor", methodSig: "(Ljava/lang/Class;)Z", methodCache: &StatementForward.isWrapperFor_MethodID_82, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw SQLException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    override open func isWrapperFor( _ _arg0: java_lang.Class? ) throws /* java.sql.SQLException */ -> Bool {
        return try isWrapperFor( arg0: _arg0 )
    }

}


