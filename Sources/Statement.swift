
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// interface java.sql.Statement ///

public protocol Statement: Wrapper, java_lang.AutoCloseable {

    /// public static final int java.sql.Statement.CLOSE_ALL_RESULTS

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Statement.CLOSE_CURRENT_RESULT

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Statement.EXECUTE_FAILED

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Statement.KEEP_CURRENT_RESULT

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Statement.NO_GENERATED_KEYS

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Statement.RETURN_GENERATED_KEYS

    // Skipping field: false false false false false true 

    /// public static final int java.sql.Statement.SUCCESS_NO_INFO

    // Skipping field: false false false false false true 

    /// public abstract void java.sql.Statement.addBatch(java.lang.String) throws java.sql.SQLException

    func addBatch( sql: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.cancel() throws java.sql.SQLException

    func cancel() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.clearBatch() throws java.sql.SQLException

    func clearBatch() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.clearWarnings() throws java.sql.SQLException

    func clearWarnings() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.close() throws java.sql.SQLException

    func close() throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.closeOnCompletion() throws java.sql.SQLException

    func closeOnCompletion() throws /* java.sql.SQLException */

    /// public abstract boolean java.sql.Statement.execute(java.lang.String) throws java.sql.SQLException

    func execute( sql: String? ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int) throws java.sql.SQLException

    func execute( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int[]) throws java.sql.SQLException

    func execute( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    func execute( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract int[] java.sql.Statement.executeBatch() throws java.sql.SQLException

    func executeBatch() throws /* java.sql.SQLException */ -> [Int32]!

    /// public default long[] java.sql.Statement.executeLargeBatch() throws java.sql.SQLException

    func executeLargeBatch() throws /* java.sql.SQLException */ -> [Int64]!

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String) throws java.sql.SQLException

    func executeLargeUpdate( sql: String? ) throws /* java.sql.SQLException */ -> Int64

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,int) throws java.sql.SQLException

    func executeLargeUpdate( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int64

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    func executeLargeUpdate( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int64

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    func executeLargeUpdate( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int64

    /// public abstract java.sql.ResultSet java.sql.Statement.executeQuery(java.lang.String) throws java.sql.SQLException

    func executeQuery( sql: String? ) throws /* java.sql.SQLException */ -> ResultSet!

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String) throws java.sql.SQLException

    func executeUpdate( sql: String? ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int) throws java.sql.SQLException

    func executeUpdate( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    func executeUpdate( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    func executeUpdate( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int

    /// public abstract java.sql.Connection java.sql.Statement.getConnection() throws java.sql.SQLException

    func getConnection() throws /* java.sql.SQLException */ -> Connection!

    /// public abstract int java.sql.Statement.getFetchDirection() throws java.sql.SQLException

    func getFetchDirection() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.getFetchSize() throws java.sql.SQLException

    func getFetchSize() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.sql.ResultSet java.sql.Statement.getGeneratedKeys() throws java.sql.SQLException

    func getGeneratedKeys() throws /* java.sql.SQLException */ -> ResultSet!

    /// public default long java.sql.Statement.getLargeMaxRows() throws java.sql.SQLException

    func getLargeMaxRows() throws /* java.sql.SQLException */ -> Int64

    /// public default long java.sql.Statement.getLargeUpdateCount() throws java.sql.SQLException

    func getLargeUpdateCount() throws /* java.sql.SQLException */ -> Int64

    /// public abstract int java.sql.Statement.getMaxFieldSize() throws java.sql.SQLException

    func getMaxFieldSize() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.getMaxRows() throws java.sql.SQLException

    func getMaxRows() throws /* java.sql.SQLException */ -> Int

    /// public abstract boolean java.sql.Statement.getMoreResults(int) throws java.sql.SQLException

    func getMoreResults( current: Int ) throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.getMoreResults() throws java.sql.SQLException

    func getMoreResults() throws /* java.sql.SQLException */ -> Bool

    /// public abstract int java.sql.Statement.getQueryTimeout() throws java.sql.SQLException

    func getQueryTimeout() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.sql.ResultSet java.sql.Statement.getResultSet() throws java.sql.SQLException

    func getResultSet() throws /* java.sql.SQLException */ -> ResultSet!

    /// public abstract int java.sql.Statement.getResultSetConcurrency() throws java.sql.SQLException

    func getResultSetConcurrency() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.getResultSetHoldability() throws java.sql.SQLException

    func getResultSetHoldability() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.getResultSetType() throws java.sql.SQLException

    func getResultSetType() throws /* java.sql.SQLException */ -> Int

    /// public abstract int java.sql.Statement.getUpdateCount() throws java.sql.SQLException

    func getUpdateCount() throws /* java.sql.SQLException */ -> Int

    /// public abstract java.sql.SQLWarning java.sql.Statement.getWarnings() throws java.sql.SQLException

    func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning!

    /// public abstract boolean java.sql.Statement.isCloseOnCompletion() throws java.sql.SQLException

    func isCloseOnCompletion() throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.isClosed() throws java.sql.SQLException

    func isClosed() throws /* java.sql.SQLException */ -> Bool

    /// public abstract boolean java.sql.Statement.isPoolable() throws java.sql.SQLException

    func isPoolable() throws /* java.sql.SQLException */ -> Bool

    /// public abstract void java.sql.Statement.setCursorName(java.lang.String) throws java.sql.SQLException

    func setCursorName( name: String? ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setEscapeProcessing(boolean) throws java.sql.SQLException

    func setEscapeProcessing( enable: Bool ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setFetchDirection(int) throws java.sql.SQLException

    func setFetchDirection( direction: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setFetchSize(int) throws java.sql.SQLException

    func setFetchSize( rows: Int ) throws /* java.sql.SQLException */

    /// public default void java.sql.Statement.setLargeMaxRows(long) throws java.sql.SQLException

    func setLargeMaxRows( max: Int64 ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setMaxFieldSize(int) throws java.sql.SQLException

    func setMaxFieldSize( max: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setMaxRows(int) throws java.sql.SQLException

    func setMaxRows( max: Int ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setPoolable(boolean) throws java.sql.SQLException

    func setPoolable( poolable: Bool ) throws /* java.sql.SQLException */

    /// public abstract void java.sql.Statement.setQueryTimeout(int) throws java.sql.SQLException

    func setQueryTimeout( seconds: Int ) throws /* java.sql.SQLException */

}


open class StatementForward: WrapperForward, Statement {

    private static var StatementJNIClass: jclass?

    /// public static final int java.sql.Statement.CLOSE_ALL_RESULTS

    private static var CLOSE_ALL_RESULTS_FieldID: jfieldID?

    public static var CLOSE_ALL_RESULTS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CLOSE_ALL_RESULTS", fieldType: "I", fieldCache: &CLOSE_ALL_RESULTS_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Statement.CLOSE_CURRENT_RESULT

    private static var CLOSE_CURRENT_RESULT_FieldID: jfieldID?

    public static var CLOSE_CURRENT_RESULT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CLOSE_CURRENT_RESULT", fieldType: "I", fieldCache: &CLOSE_CURRENT_RESULT_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Statement.EXECUTE_FAILED

    private static var EXECUTE_FAILED_FieldID: jfieldID?

    public static var EXECUTE_FAILED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "EXECUTE_FAILED", fieldType: "I", fieldCache: &EXECUTE_FAILED_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Statement.KEEP_CURRENT_RESULT

    private static var KEEP_CURRENT_RESULT_FieldID: jfieldID?

    public static var KEEP_CURRENT_RESULT: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "KEEP_CURRENT_RESULT", fieldType: "I", fieldCache: &KEEP_CURRENT_RESULT_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Statement.NO_GENERATED_KEYS

    private static var NO_GENERATED_KEYS_FieldID: jfieldID?

    public static var NO_GENERATED_KEYS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "NO_GENERATED_KEYS", fieldType: "I", fieldCache: &NO_GENERATED_KEYS_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Statement.RETURN_GENERATED_KEYS

    private static var RETURN_GENERATED_KEYS_FieldID: jfieldID?

    public static var RETURN_GENERATED_KEYS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "RETURN_GENERATED_KEYS", fieldType: "I", fieldCache: &RETURN_GENERATED_KEYS_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public static final int java.sql.Statement.SUCCESS_NO_INFO

    private static var SUCCESS_NO_INFO_FieldID: jfieldID?

    public static var SUCCESS_NO_INFO: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "SUCCESS_NO_INFO", fieldType: "I", fieldCache: &SUCCESS_NO_INFO_FieldID, className: "java/sql/Statement", classCache: &StatementJNIClass )
            return Int(__value)
        }
    }

    /// public abstract void java.sql.Statement.addBatch(java.lang.String) throws java.sql.SQLException

    private static var addBatch_MethodID_51: jmethodID?

    open func addBatch( sql: String? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addBatch", methodSig: "(Ljava/lang/String;)V", methodCache: &StatementForward.addBatch_MethodID_51, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func addBatch( _ _sql: String? ) throws /* java.sql.SQLException */ {
        try addBatch( sql: _sql )
    }

    /// public abstract void java.sql.Statement.cancel() throws java.sql.SQLException

    private static var cancel_MethodID_52: jmethodID?

    open func cancel() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "cancel", methodSig: "()V", methodCache: &StatementForward.cancel_MethodID_52, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.clearBatch() throws java.sql.SQLException

    private static var clearBatch_MethodID_53: jmethodID?

    open func clearBatch() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearBatch", methodSig: "()V", methodCache: &StatementForward.clearBatch_MethodID_53, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.clearWarnings() throws java.sql.SQLException

    private static var clearWarnings_MethodID_54: jmethodID?

    open func clearWarnings() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "clearWarnings", methodSig: "()V", methodCache: &StatementForward.clearWarnings_MethodID_54, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.close() throws java.sql.SQLException

    private static var close_MethodID_55: jmethodID?

    open func close() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &StatementForward.close_MethodID_55, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract void java.sql.Statement.closeOnCompletion() throws java.sql.SQLException

    private static var closeOnCompletion_MethodID_56: jmethodID?

    open func closeOnCompletion() throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "closeOnCompletion", methodSig: "()V", methodCache: &StatementForward.closeOnCompletion_MethodID_56, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }


    /// public abstract boolean java.sql.Statement.execute(java.lang.String) throws java.sql.SQLException

    private static var execute_MethodID_57: jmethodID?

    open func execute( sql: String? ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;)Z", methodCache: &StatementForward.execute_MethodID_57, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func execute( _ _sql: String? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int) throws java.sql.SQLException

    private static var execute_MethodID_58: jmethodID?

    open func execute( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(autoGeneratedKeys) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;I)Z", methodCache: &StatementForward.execute_MethodID_58, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func execute( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,int[]) throws java.sql.SQLException

    private static var execute_MethodID_59: jmethodID?

    open func execute( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;[I)Z", methodCache: &StatementForward.execute_MethodID_59, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func execute( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public abstract boolean java.sql.Statement.execute(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var execute_MethodID_60: jmethodID?

    open func execute( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "execute", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)Z", methodCache: &StatementForward.execute_MethodID_60, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func execute( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> Bool {
        return try execute( sql: _sql, columnNames: _columnNames )
    }

    /// public abstract int[] java.sql.Statement.executeBatch() throws java.sql.SQLException

    private static var executeBatch_MethodID_61: jmethodID?

    open func executeBatch() throws /* java.sql.SQLException */ -> [Int32]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeBatch", methodSig: "()[I", methodCache: &StatementForward.executeBatch_MethodID_61, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: [Int32].self, from: __return )
    }


    /// public default long[] java.sql.Statement.executeLargeBatch() throws java.sql.SQLException

    private static var executeLargeBatch_MethodID_62: jmethodID?

    open func executeLargeBatch() throws /* java.sql.SQLException */ -> [Int64]! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeLargeBatch", methodSig: "()[J", methodCache: &StatementForward.executeLargeBatch_MethodID_62, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return JNIType.toSwift( type: [Int64].self, from: __return )
    }


    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_63: jmethodID?

    open func executeLargeUpdate( sql: String? ) throws /* java.sql.SQLException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;)J", methodCache: &StatementForward.executeLargeUpdate_MethodID_63, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return
    }

    open func executeLargeUpdate( _ _sql: String? ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,int) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_64: jmethodID?

    open func executeLargeUpdate( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(autoGeneratedKeys) )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;I)J", methodCache: &StatementForward.executeLargeUpdate_MethodID_64, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return
    }

    open func executeLargeUpdate( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_65: jmethodID?

    open func executeLargeUpdate( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;[I)J", methodCache: &StatementForward.executeLargeUpdate_MethodID_65, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return
    }

    open func executeLargeUpdate( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public default long java.sql.Statement.executeLargeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var executeLargeUpdate_MethodID_66: jmethodID?

    open func executeLargeUpdate( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "executeLargeUpdate", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)J", methodCache: &StatementForward.executeLargeUpdate_MethodID_66, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return
    }

    open func executeLargeUpdate( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int64 {
        return try executeLargeUpdate( sql: _sql, columnNames: _columnNames )
    }

    /// public abstract java.sql.ResultSet java.sql.Statement.executeQuery(java.lang.String) throws java.sql.SQLException

    private static var executeQuery_MethodID_67: jmethodID?

    open func executeQuery( sql: String? ) throws /* java.sql.SQLException */ -> ResultSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "executeQuery", methodSig: "(Ljava/lang/String;)Ljava/sql/ResultSet;", methodCache: &StatementForward.executeQuery_MethodID_67, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }

    open func executeQuery( _ _sql: String? ) throws /* java.sql.SQLException */ -> ResultSet! {
        return try executeQuery( sql: _sql )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String) throws java.sql.SQLException

    private static var executeUpdate_MethodID_68: jmethodID?

    open func executeUpdate( sql: String? ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;)I", methodCache: &StatementForward.executeUpdate_MethodID_68, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func executeUpdate( _ _sql: String? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int) throws java.sql.SQLException

    private static var executeUpdate_MethodID_69: jmethodID?

    open func executeUpdate( sql: String?, autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = jvalue( i: jint(autoGeneratedKeys) )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;I)I", methodCache: &StatementForward.executeUpdate_MethodID_69, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func executeUpdate( _ _sql: String?, _ _autoGeneratedKeys: Int ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql, autoGeneratedKeys: _autoGeneratedKeys )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,int[]) throws java.sql.SQLException

    private static var executeUpdate_MethodID_70: jmethodID?

    open func executeUpdate( sql: String?, columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnIndexes, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;[I)I", methodCache: &StatementForward.executeUpdate_MethodID_70, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func executeUpdate( _ _sql: String?, _ _columnIndexes: [Int32]? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql, columnIndexes: _columnIndexes )
    }

    /// public abstract int java.sql.Statement.executeUpdate(java.lang.String,java.lang.String[]) throws java.sql.SQLException

    private static var executeUpdate_MethodID_71: jmethodID?

    open func executeUpdate( sql: String?, columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        __args[0] = JNIType.toJava( value: sql, locals: &__locals )
        __args[1] = JNIType.toJava( value: columnNames, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "executeUpdate", methodSig: "(Ljava/lang/String;[Ljava/lang/String;)I", methodCache: &StatementForward.executeUpdate_MethodID_71, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }

    open func executeUpdate( _ _sql: String?, _ _columnNames: [String]? ) throws /* java.sql.SQLException */ -> Int {
        return try executeUpdate( sql: _sql, columnNames: _columnNames )
    }

    /// public abstract java.sql.Connection java.sql.Statement.getConnection() throws java.sql.SQLException

    private static var getConnection_MethodID_72: jmethodID?

    open func getConnection() throws /* java.sql.SQLException */ -> Connection! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConnection", methodSig: "()Ljava/sql/Connection;", methodCache: &StatementForward.getConnection_MethodID_72, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ConnectionForward( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.Statement.getFetchDirection() throws java.sql.SQLException

    private static var getFetchDirection_MethodID_73: jmethodID?

    open func getFetchDirection() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getFetchDirection", methodSig: "()I", methodCache: &StatementForward.getFetchDirection_MethodID_73, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract int java.sql.Statement.getFetchSize() throws java.sql.SQLException

    private static var getFetchSize_MethodID_74: jmethodID?

    open func getFetchSize() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getFetchSize", methodSig: "()I", methodCache: &StatementForward.getFetchSize_MethodID_74, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.getGeneratedKeys() throws java.sql.SQLException

    private static var getGeneratedKeys_MethodID_75: jmethodID?

    open func getGeneratedKeys() throws /* java.sql.SQLException */ -> ResultSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGeneratedKeys", methodSig: "()Ljava/sql/ResultSet;", methodCache: &StatementForward.getGeneratedKeys_MethodID_75, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public default long java.sql.Statement.getLargeMaxRows() throws java.sql.SQLException

    private static var getLargeMaxRows_MethodID_76: jmethodID?

    open func getLargeMaxRows() throws /* java.sql.SQLException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getLargeMaxRows", methodSig: "()J", methodCache: &StatementForward.getLargeMaxRows_MethodID_76, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return
    }


    /// public default long java.sql.Statement.getLargeUpdateCount() throws java.sql.SQLException

    private static var getLargeUpdateCount_MethodID_77: jmethodID?

    open func getLargeUpdateCount() throws /* java.sql.SQLException */ -> Int64 {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getLargeUpdateCount", methodSig: "()J", methodCache: &StatementForward.getLargeUpdateCount_MethodID_77, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return
    }


    /// public abstract int java.sql.Statement.getMaxFieldSize() throws java.sql.SQLException

    private static var getMaxFieldSize_MethodID_78: jmethodID?

    open func getMaxFieldSize() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMaxFieldSize", methodSig: "()I", methodCache: &StatementForward.getMaxFieldSize_MethodID_78, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract int java.sql.Statement.getMaxRows() throws java.sql.SQLException

    private static var getMaxRows_MethodID_79: jmethodID?

    open func getMaxRows() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getMaxRows", methodSig: "()I", methodCache: &StatementForward.getMaxRows_MethodID_79, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract boolean java.sql.Statement.getMoreResults(int) throws java.sql.SQLException

    private static var getMoreResults_MethodID_80: jmethodID?

    open func getMoreResults( current: Int ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(current) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getMoreResults", methodSig: "(I)Z", methodCache: &StatementForward.getMoreResults_MethodID_80, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    open func getMoreResults( _ _current: Int ) throws /* java.sql.SQLException */ -> Bool {
        return try getMoreResults( current: _current )
    }

    /// public abstract boolean java.sql.Statement.getMoreResults() throws java.sql.SQLException

    private static var getMoreResults_MethodID_81: jmethodID?

    open func getMoreResults() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getMoreResults", methodSig: "()Z", methodCache: &StatementForward.getMoreResults_MethodID_81, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract int java.sql.Statement.getQueryTimeout() throws java.sql.SQLException

    private static var getQueryTimeout_MethodID_82: jmethodID?

    open func getQueryTimeout() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getQueryTimeout", methodSig: "()I", methodCache: &StatementForward.getQueryTimeout_MethodID_82, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract java.sql.ResultSet java.sql.Statement.getResultSet() throws java.sql.SQLException

    private static var getResultSet_MethodID_83: jmethodID?

    open func getResultSet() throws /* java.sql.SQLException */ -> ResultSet! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResultSet", methodSig: "()Ljava/sql/ResultSet;", methodCache: &StatementForward.getResultSet_MethodID_83, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? ResultSetForward( javaObject: __return ) : nil
    }


    /// public abstract int java.sql.Statement.getResultSetConcurrency() throws java.sql.SQLException

    private static var getResultSetConcurrency_MethodID_84: jmethodID?

    open func getResultSetConcurrency() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetConcurrency", methodSig: "()I", methodCache: &StatementForward.getResultSetConcurrency_MethodID_84, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract int java.sql.Statement.getResultSetHoldability() throws java.sql.SQLException

    private static var getResultSetHoldability_MethodID_85: jmethodID?

    open func getResultSetHoldability() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetHoldability", methodSig: "()I", methodCache: &StatementForward.getResultSetHoldability_MethodID_85, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract int java.sql.Statement.getResultSetType() throws java.sql.SQLException

    private static var getResultSetType_MethodID_86: jmethodID?

    open func getResultSetType() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getResultSetType", methodSig: "()I", methodCache: &StatementForward.getResultSetType_MethodID_86, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract int java.sql.Statement.getUpdateCount() throws java.sql.SQLException

    private static var getUpdateCount_MethodID_87: jmethodID?

    open func getUpdateCount() throws /* java.sql.SQLException */ -> Int {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getUpdateCount", methodSig: "()I", methodCache: &StatementForward.getUpdateCount_MethodID_87, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return Int(__return)
    }


    /// public abstract java.sql.SQLWarning java.sql.Statement.getWarnings() throws java.sql.SQLException

    private static var getWarnings_MethodID_88: jmethodID?

    open func getWarnings() throws /* java.sql.SQLException */ -> SQLWarning! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getWarnings", methodSig: "()Ljava/sql/SQLWarning;", methodCache: &StatementForward.getWarnings_MethodID_88, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? SQLWarning( javaObject: __return ) : nil
    }


    /// public abstract boolean java.sql.Statement.isCloseOnCompletion() throws java.sql.SQLException

    private static var isCloseOnCompletion_MethodID_89: jmethodID?

    open func isCloseOnCompletion() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCloseOnCompletion", methodSig: "()Z", methodCache: &StatementForward.isCloseOnCompletion_MethodID_89, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.sql.Statement.isClosed() throws java.sql.SQLException

    private static var isClosed_MethodID_90: jmethodID?

    open func isClosed() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isClosed", methodSig: "()Z", methodCache: &StatementForward.isClosed_MethodID_90, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.sql.Statement.isPoolable() throws java.sql.SQLException

    private static var isPoolable_MethodID_91: jmethodID?

    open func isPoolable() throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isPoolable", methodSig: "()Z", methodCache: &StatementForward.isPoolable_MethodID_91, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }


    /// public abstract boolean java.sql.Wrapper.isWrapperFor(java.lang.Class) throws java.sql.SQLException

    private static var isWrapperFor_MethodID_92: jmethodID?

    override open func isWrapperFor( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: iface, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isWrapperFor", methodSig: "(Ljava/lang/Class;)Z", methodCache: &StatementForward.isWrapperFor_MethodID_92, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != jboolean(JNI_FALSE)
    }

    override open func isWrapperFor( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> Bool {
        return try isWrapperFor( iface: _iface )
    }

    /// public abstract void java.sql.Statement.setCursorName(java.lang.String) throws java.sql.SQLException

    private static var setCursorName_MethodID_93: jmethodID?

    open func setCursorName( name: String? ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setCursorName", methodSig: "(Ljava/lang/String;)V", methodCache: &StatementForward.setCursorName_MethodID_93, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setCursorName( _ _name: String? ) throws /* java.sql.SQLException */ {
        try setCursorName( name: _name )
    }

    /// public abstract void java.sql.Statement.setEscapeProcessing(boolean) throws java.sql.SQLException

    private static var setEscapeProcessing_MethodID_94: jmethodID?

    open func setEscapeProcessing( enable: Bool ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(enable ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setEscapeProcessing", methodSig: "(Z)V", methodCache: &StatementForward.setEscapeProcessing_MethodID_94, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setEscapeProcessing( _ _enable: Bool ) throws /* java.sql.SQLException */ {
        try setEscapeProcessing( enable: _enable )
    }

    /// public abstract void java.sql.Statement.setFetchDirection(int) throws java.sql.SQLException

    private static var setFetchDirection_MethodID_95: jmethodID?

    open func setFetchDirection( direction: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(direction) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFetchDirection", methodSig: "(I)V", methodCache: &StatementForward.setFetchDirection_MethodID_95, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setFetchDirection( _ _direction: Int ) throws /* java.sql.SQLException */ {
        try setFetchDirection( direction: _direction )
    }

    /// public abstract void java.sql.Statement.setFetchSize(int) throws java.sql.SQLException

    private static var setFetchSize_MethodID_96: jmethodID?

    open func setFetchSize( rows: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(rows) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFetchSize", methodSig: "(I)V", methodCache: &StatementForward.setFetchSize_MethodID_96, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setFetchSize( _ _rows: Int ) throws /* java.sql.SQLException */ {
        try setFetchSize( rows: _rows )
    }

    /// public default void java.sql.Statement.setLargeMaxRows(long) throws java.sql.SQLException

    private static var setLargeMaxRows_MethodID_97: jmethodID?

    open func setLargeMaxRows( max: Int64 ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( j: max )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLargeMaxRows", methodSig: "(J)V", methodCache: &StatementForward.setLargeMaxRows_MethodID_97, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setLargeMaxRows( _ _max: Int64 ) throws /* java.sql.SQLException */ {
        try setLargeMaxRows( max: _max )
    }

    /// public abstract void java.sql.Statement.setMaxFieldSize(int) throws java.sql.SQLException

    private static var setMaxFieldSize_MethodID_98: jmethodID?

    open func setMaxFieldSize( max: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(max) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setMaxFieldSize", methodSig: "(I)V", methodCache: &StatementForward.setMaxFieldSize_MethodID_98, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setMaxFieldSize( _ _max: Int ) throws /* java.sql.SQLException */ {
        try setMaxFieldSize( max: _max )
    }

    /// public abstract void java.sql.Statement.setMaxRows(int) throws java.sql.SQLException

    private static var setMaxRows_MethodID_99: jmethodID?

    open func setMaxRows( max: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(max) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setMaxRows", methodSig: "(I)V", methodCache: &StatementForward.setMaxRows_MethodID_99, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setMaxRows( _ _max: Int ) throws /* java.sql.SQLException */ {
        try setMaxRows( max: _max )
    }

    /// public abstract void java.sql.Statement.setPoolable(boolean) throws java.sql.SQLException

    private static var setPoolable_MethodID_100: jmethodID?

    open func setPoolable( poolable: Bool ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( z: jboolean(poolable ? JNI_TRUE : JNI_FALSE) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setPoolable", methodSig: "(Z)V", methodCache: &StatementForward.setPoolable_MethodID_100, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setPoolable( _ _poolable: Bool ) throws /* java.sql.SQLException */ {
        try setPoolable( poolable: _poolable )
    }

    /// public abstract void java.sql.Statement.setQueryTimeout(int) throws java.sql.SQLException

    private static var setQueryTimeout_MethodID_101: jmethodID?

    open func setQueryTimeout( seconds: Int ) throws /* java.sql.SQLException */ {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = jvalue( i: jint(seconds) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setQueryTimeout", methodSig: "(I)V", methodCache: &StatementForward.setQueryTimeout_MethodID_101, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
    }

    open func setQueryTimeout( _ _seconds: Int ) throws /* java.sql.SQLException */ {
        try setQueryTimeout( seconds: _seconds )
    }

    /// public abstract java.lang.Object java.sql.Wrapper.unwrap(java.lang.Class) throws java.sql.SQLException

    private static var unwrap_MethodID_102: jmethodID?

    override open func unwrap( iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        var __locals = [jobject]()
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        __args[0] = JNIType.toJava( value: iface, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "unwrap", methodSig: "(Ljava/lang/Class;)Ljava/lang/Object;", methodCache: &StatementForward.unwrap_MethodID_102, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            defer { JNI.DeleteLocalRef( throwable ) }
            throw SQLException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }

    override open func unwrap( _ _iface: java_swift.JavaClass? ) throws /* java.sql.SQLException */ -> java_swift.JavaObject! {
        return try unwrap( iface: _iface )
    }

}

